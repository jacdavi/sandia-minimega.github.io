
<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Minimega API</title>
	<link rel="stylesheet" href="css/api.css">
	
</head>

<body>
    <header>
		
    </header>
    <!-- TOP NAVIGATION MENU-->
		<nav class="floating-menu">
<h3>Navigation</h3>
<a href="#header_1.1">Introduction</a>
<a href="#header_2.1">Builtins</a>
<a href="#header_3.1">Mesh Commands</a>
<a href="#header_4.1">VM Commands</a>
<a href="#header_5.1">Host and Other Commands</a>
</nav>

    <!-- MAIN MENU -->
    <main>
        <p>
minimega API<br/></p>
<p>Auto-generated by apigen<br/>Last updated 24 January 2023<br/></p>
<p><h2 id="header_1.1">Introduction</h2>
</p>
<p>This document contains an automatically generated form of the minimega command<br/>API help text. The same help text (minus some examples included here) is<br/>available in minimega by using the `help` command. You can get specific help on<br/>a minimega command by using `help`&lt;command&gt;`.<br/></p>
<p><h2 id="header_2.1">Builtins</h2>
</p>
<p>Builtins are commands that impact how responses to commands are rendered. Some<br/>builtins impact how data is displayed, such as `.csv` and `.json`, while other<br/>impact what data is displayed, such as `.columns`. All builtins are stackable,<br/>meaning you can issue one-line commands by suffixing a builtin with a command<br/>or another builtin.<br/>
<p><h3 id="header_2.2">.alias</h3>
</p>
<p><code> .alias<br/>
 .alias &lt;alias&gt;...<br/>
</code><br/></p>
<p>Create a new alias similar to bash aliases. Aliases can be used as a shortcut<br/>to avoid typing out a long command. Only one alias is applied per command and<br/>only to the beginning of a command. For example:<br/></p>
<p><code> .alias vmr=.filter state=running vm info<br/>
</code><br/></p>
<p>The alias is interpreted as the text up to the first "=". Runing .alias without<br/>any argument will list the existing aliases.<br/></p>
<p>This alias allows the user to type "vmr" rather than the using a filter to list<br/>the running VMs.<br/></p>
<p><code> .unalias removes a previously set alias.<br/>
</code><br/></p>
<p>Note: we *strongly* recommend that you avoid aliases, unless you are using the<br/>shell interactively. Aliases save typing which should not be necessary if you<br/>are writing a script.<br/>
<p><h3 id="header_2.3">.annotate</h3>
</p>
<p><code> .annotate [true,false]<br/>
 .annotate &lt;true,false&gt; (command)<br/>
</code><br/></p>
<p>Enable or disable hostname annotation for responses.<br/>
<p><h3 id="header_2.4">.columns</h3>
</p>
<p><code> .columns &lt;columns as csv&gt; (command)<br/>
</code><br/></p>
<p>Filter tabular data using particular column names. For example, to display<br/>only the vm name and state:<br/></p>
<p><code>	.columns name,state vm info<br/>
</code><br/></p>
<p>Column names are comma-seperated. .columns can be used in conjunction with<br/>.filter to slice a subset of the rows and columns from a command, however,<br/>these commands are not always interchangeable. For example, the following is<br/>acceptable:<br/></p>
<p><code>	.columns name,state .filter vcpus=4 vm info<br/>
</code><br/></p>
<p>While the following is not:<br/></p>
<p><code>	.filter vcpus=4 .columns name,state vm info<br/>
</code><br/></p>
<p>This is because .columns strips all columns except for name and state from the<br/>tabular data.<br/></p>
<p>Note: the annotate flag controls the presence of the host column.<br/>
<p><h3 id="header_2.5">.compress</h3>
</p>
<p><code> .compress [true,false]<br/>
 .compress &lt;true,false&gt; (command)<br/>
</code><br/></p>
<p>Enable or disable output compression of like output from multiple responses.<br/>For example, if you executed a command using mesh, such as:<br/></p>
<p><code>	mesh send node[0-9] version<br/>
</code><br/></p>
<p>You would expect to get the same minimega version for all 10 nodes. Rather than<br/>print out the same version 10 times, minicli with compression enabled would print:<br/></p>
<p><code>	node[0-9]: minimega &lt;version&gt;<br/>
</code><br/></p>
<p>Assuming that all the minimega instances are running the same version. If one node was running<br/>a different version or has an error, compression is still useful:<br/></p>
<p><code>	node[0-4,6-9]: minimega &lt;version&gt;<br/>
	node5: minimega &lt;version&gt;<br/>
</code><br/></p>
<p>Or,<br/></p>
<p><code>	node[0-3,9]: minimega &lt;version&gt;<br/>
	node[4-8]: Error: &lt;error&gt;<br/>
</code><br/></p>
<p>Compression is not applied when the output mode is JSON.<br/>
<p><h3 id="header_2.6">.csv</h3>
</p>
<p><code> .csv [true,false]<br/>
 .csv &lt;true,false&gt; (command)<br/>
</code><br/></p>
<p>Enable or disable CSV mode. Enabling CSV mode disables JSON mode, if enabled.<br/>
<p><h3 id="header_2.7">.env</h3>
</p>
<p><code> .env [name]<br/>
 .env &lt;name&gt; &lt;value&gt;<br/>
</code><br/></p>
<p>Print or update env variables. To unset an env variables, use:<br/></p>
<p><code>	.env &lt;name&gt; ""<br/>
</code><br/>
<p><h3 id="header_2.8">.filter</h3>
</p>
<p><code> .filter &lt;filter&gt; (command)<br/>
</code><br/></p>
<p>Filters tabular data based on the value in a particular column. For example, to<br/>search for vms in a particular state:<br/></p>
<p><code>	.filter state=running vm info<br/>
</code><br/></p>
<p>Filters can also be inverted:<br/></p>
<p><code>	.filter state!=running vm info<br/>
</code><br/></p>
<p>Filters are case insensitive and may be stacked:<br/></p>
<p><code>	.filter state=RUNNING .filter vcpus=4 vm info<br/>
</code><br/></p>
<p>If the column value is a list or an object (i.e. "[...]", "{...}"), then<br/>.filter implicitly uses substring matching.<br/></p>
<p>Substring matching can be specified explicity:<br/></p>
<p><code>	.filter state~run vm info<br/>
	.filter state!~run vm info<br/>
</code><br/>
<p><h3 id="header_2.9">.headers</h3>
</p>
<p><code> .headers [true,false]<br/>
 .headers &lt;true,false&gt; (command)<br/>
</code><br/></p>
<p>Enable or disable headers for tabular data.<br/>
<p><h3 id="header_2.10">.json</h3>
</p>
<p><code> .json [true,false]<br/>
 .json &lt;true,false&gt; (command)<br/>
</code><br/></p>
<p>Enable or disable JSON mode. Enabling JSON mode disables CSV mode, if enabled.<br/>
<p><h3 id="header_2.11">.preprocess</h3>
</p>
<p><code> .preprocess [true,false]<br/>
 .preprocess &lt;true,false&gt; (command)<br/>
</code><br/></p>
<p>Enable or disable the command preprocessor.<br/>
<p><h3 id="header_2.12">.record</h3>
</p>
<p><code> .record [true,false]<br/>
 .record &lt;true,false&gt; (command)<br/>
</code><br/></p>
<p>Enable or disable the recording of a given command in the command history.<br/>
<p><h3 id="header_2.13">.sort</h3>
</p>
<p><code> .sort [true,false]<br/>
 .sort &lt;true,false&gt; (command)<br/>
</code><br/></p>
<p>Enable or disable sorting of tabular data based on the value in the first<br/>column. Sorting is based on string comparison.<br/>
<p><h3 id="header_2.14">.unalias</h3>
</p>
<p><code> .unalias &lt;alias&gt;<br/>
</code><br/></p>
<p>Removes an alias by name. See .alias for a listing of aliases.<br/>
<p><h2 id="header_3.1">Mesh Commands</h2>
</p>
<p>Mesh commands control the behavior and operation of communication between<br/>minimega nodes on a network. minimega is fully distributed, and commands to<br/>other minimega nodes can be issued from any other participating minimega node.<br/>For example, you can get the hostname of all minimega nodes (exclusive of the<br/>issuing node) with `mesh`send`all`host`name`.<br/></p>
<p>Generally, `mesh`send` will be the only mesh command you will use. The other<br/>commands provided are for manually dialing other nodes and controlling network<br/>behavior.<br/>
<p><h3 id="header_3.2">mesh degree</h3>
</p>
<p><code> mesh degree [degree]<br/>
</code><br/>
<p><h3 id="header_3.3">mesh dial</h3>
</p>
<p><code> mesh dial &lt;hostname&gt;<br/>
</code><br/>
<p><h3 id="header_3.4">mesh dot</h3>
</p>
<p><code> mesh dot &lt;filename&gt;<br/>
</code><br/></p>
<p>Output a graphviz formatted dot file representing the connected topology.<br/>
<p><h3 id="header_3.5">mesh hangup</h3>
</p>
<p><code> mesh hangup &lt;hostname&gt;<br/>
</code><br/>
<p><h3 id="header_3.6">mesh list</h3>
</p>
<p><code> mesh list [all,peers]<br/>
</code><br/></p>
<p>Without "all" or "peers", displays the mesh adjacency list. If "all" is<br/>specified, the hostnames of all nodes in the list are printed. If "peers" is<br/>specified, the hostnames of all peers are printed (the local node is not<br/>included).<br/>
<p><h3 id="header_3.7">mesh send</h3>
</p>
<p><code> mesh send &lt;hostname or range or all&gt; (command)<br/>
</code><br/></p>
<p>Send a command to one or more connected clients. For example, to get the<br/>vm info from nodes kn1 and kn2:<br/></p>
<p><code>	mesh send kn[1-2] vm info<br/>
</code><br/></p>
<p>You can use 'all' to send a command to all connected clients.<br/>
<p><h3 id="header_3.8">mesh status</h3>
</p>
<p><code> mesh status<br/>
</code><br/>
<p><h3 id="header_3.9">mesh timeout</h3>
</p>
<p><code> mesh timeout [timeout]<br/>
</code><br/></p>
<p>View or set the timeout on sending mesh commands.<br/></p>
<p>When a mesh command is issued, if a response isn't sent within mesh timeout<br/>seconds, the command will be dropped and any future response will be discarded.<br/><ul><li>Note that this does not cancel the outstanding command  the node receiving the</li>
<li>command may still complete  but rather this node will stop waiting on a</li>
</ul><br/>response.<br/></p>
<p>By default, the mesh timeout is 0 which disables timeouts.<br/>
<p><h2 id="header_4.1">VM Commands</h2>
</p>
<p>VM commands control the state, monitoring, and launching of VMs on a minimega<br/>node. VMs are launched by describing the VM parameters with the various<br/>`vm`config` commands. One the VM is described, one or more instances of that<br/>description may be launched. The VM description can be modified for subsequent<br/>VMs.<br/>
<p><h3 id="header_4.2">clear vm config</h3>
</p>
<p><code> clear vm config<br/>
 clear vm config &lt;append,&gt;<br/>
 clear vm config &lt;backchannel,&gt;<br/>
 clear vm config &lt;cpu,&gt;<br/>
 clear vm config &lt;cdrom,&gt;<br/>
 clear vm config &lt;colocate,&gt;<br/>
 clear vm config &lt;cores,&gt;<br/>
 clear vm config &lt;coschedule,&gt;<br/>
 clear vm config &lt;disks,&gt;<br/>
 clear vm config &lt;fifos,&gt;<br/>
 clear vm config &lt;filesystem,&gt;<br/>
 clear vm config &lt;hostname,&gt;<br/>
 clear vm config &lt;init,&gt;<br/>
 clear vm config &lt;initrd,&gt;<br/>
 clear vm config &lt;kernel,&gt;<br/>
 clear vm config &lt;machine,&gt;<br/>
 clear vm config &lt;memory,&gt;<br/>
 clear vm config &lt;migrate,&gt;<br/>
 clear vm config &lt;networks,&gt;<br/>
 clear vm config &lt;preinit,&gt;<br/>
 clear vm config &lt;qemu-append,&gt;<br/>
 clear vm config &lt;qemu-override,&gt;<br/>
 clear vm config &lt;qemu,&gt;<br/>
 clear vm config &lt;schedule,&gt;<br/>
 clear vm config &lt;serial-ports,&gt;<br/>
 clear vm config &lt;snapshot,&gt;<br/>
 clear vm config &lt;sockets,&gt;<br/>
 clear vm config &lt;tags,&gt;<br/>
 clear vm config &lt;threads,&gt;<br/>
 clear vm config &lt;uuid,&gt;<br/>
 clear vm config &lt;vcpus,&gt;<br/>
 clear vm config &lt;vga,&gt;<br/>
 clear vm config &lt;virtio-ports,&gt;<br/>
 clear vm config &lt;volume,&gt;<br/>
</code><br/>
<p><h3 id="header_4.3">clear vm config tag</h3>
</p>
<p><code> clear vm config tag &lt;key&gt;<br/>
</code><br/></p>
<p>Remove tags in the same manner as "clear vm tag".<br/>
<p><h3 id="header_4.4">clear vm net bond</h3>
</p>
<p><code> clear vm net bond &lt;vm target&gt; [name]<br/>
</code><br/>
<p><h3 id="header_4.5">clear vm tag</h3>
</p>
<p><code> clear vm tag<br/>
 clear vm tag &lt;vm target&gt; [tag]<br/>
</code><br/></p>
<p>Clears one, many, or all tags from a virtual machine.<br/></p>
<p>Clear the tag "foo" from VM 0:<br/></p>
<p><code>        clear vm tag 0 foo<br/>
</code><br/></p>
<p>Clear the tag "foo" from all VMs:<br/></p>
<p><code>        clear vm tag all foo<br/>
</code><br/></p>
<p>Clear all tags from VM 0:<br/></p>
<p><code>        clear vm tag 0<br/>
</code><br/></p>
<p>Clear all tags from all VMs:<br/></p>
<p><code>        clear vm tag all<br/>
</code><br/>
<p><h3 id="header_4.6">vm</h3>
</p>
<p><code> vm &lt;kill,&gt; &lt;vm target&gt;<br/>
 vm &lt;stop,&gt; &lt;vm target&gt;<br/>
 vm &lt;flush,&gt;<br/>
 vm &lt;flush,&gt; &lt;vm target&gt;<br/>
 vm &lt;start,&gt; &lt;vm target&gt;<br/>
</code><br/></p>
<p>Kill one or more running virtual machines. See "vm start" for a full<br/>description of allowable targets.<br/>Stop one or more running virtual machines. See "vm start" for a full<br/>description of allowable targets.<br/></p>
<p>Calling stop will put VMs in a paused state. Use "vm start" to restart them.<br/>Flush one or more virtual machines. Discard information about VMs that<br/>have either quit or encountered an error. This will remove VMs with a state of<br/>"quit" or "error" from vm info. Names of VMs that have been flushed may be<br/>reused.<br/></p>
<p>Note running without arguments results in the same behavior as using the "all"<br/>target. See "vm start" for a full description of allowable targets.<br/>Start one or more paused virtual machines. VMs may be selected by name, range, or<br/>wildcard. For example,<br/></p>
<p>To start vm foo:<br/></p>
<p><code>		vm start foo<br/>
</code><br/></p>
<p>To start vms foo and bar:<br/></p>
<p><code>		vm start foo,bar<br/>
</code><br/></p>
<p>To start vms foo0, foo1, foo2, and foo5:<br/></p>
<p><code>		vm start foo[0-2,5]<br/>
</code><br/></p>
<p>There is also a wildcard (all) which allows the user to specify all VMs:<br/></p>
<p><code>		vm start all<br/>
</code><br/></p>
<p>Note that including the wildcard in a list of VMs results in the wildcard<br/>behavior (although a message will be logged).<br/></p>
<p>Calling "vm start" on a specific list of VMs will cause them to be started if<br/>they are in the building, paused, quit, or error states. When used with the<br/>wildcard, only vms in the building or paused state will be started.<br/>
<p><h3 id="header_4.7">vm cdrom</h3>
</p>
<p><code> vm cdrom &lt;eject,&gt; &lt;vm target&gt; [force,]<br/>
 vm cdrom &lt;change,&gt; &lt;vm target&gt; &lt;path&gt; [force,]<br/>
</code><br/></p>
<p>Eject or change an active VM's cdrom image.<br/></p>
<p>Eject VM 0's cdrom:<br/></p>
<p><code>        vm cdrom eject 0<br/>
</code><br/></p>
<p>Eject all VM cdroms:<br/></p>
<p><code>        vm cdrom eject all<br/>
</code><br/></p>
<p>If the cdrom is "locked" by the guest, the force option can be used to override<br/>the lock:<br/></p>
<p><code>        vm cdrom eject 0 force<br/>
</code><br/></p>
<p>Change a VM to use a new ISO:<br/></p>
<p><code>        vm cdrom change 0 /tmp/debian.iso<br/>
</code><br/></p>
<p>"vm cdrom change" ejects the current ISO, if there is one.<br/></p>
<p>See "vm start" for a full description of allowable targets.<br/>
<p><h3 id="header_4.8">vm config</h3>
</p>
<p><code> vm config<br/>
 vm config &lt;save,&gt; &lt;name&gt;<br/>
 vm config &lt;restore,&gt; [name]<br/>
 vm config &lt;clone,&gt; &lt;vm name&gt;<br/>
</code><br/></p>
<p>Display, save, or restore the current VM configuration. Note that saving and<br/>restoring configuration applies to all VM configurations including KVM-based VM<br/>configurations.<br/></p>
<p>To display the current configuration, call vm config with no arguments.<br/></p>
<p>List the current saved configurations with 'vm config restore'.<br/></p>
<p>To save a configuration:<br/></p>
<p><code>	vm config save &lt;config name&gt;<br/>
</code><br/></p>
<p>To restore a configuration:<br/></p>
<p><code>	vm config restore &lt;config name&gt;<br/>
</code><br/></p>
<p>To clone the configuration of an existing VM:<br/></p>
<p><code>	vm config clone &lt;vm name&gt;<br/>
</code><br/></p>
<p>Clone reparses the original network "vm config net". If the cloned VM was<br/>configured with a static MAC, the VM config will not be launchable. Clone also<br/>clears the UUID.<br/></p>
<p>Calling clear vm config will clear all VM configuration options, but will not<br/>remove saved configurations.<br/>
<p><h3 id="header_4.9">vm config append</h3>
</p>
<p><code> vm config append [value]...<br/>
</code><br/></p>
<p>Add an append string to a kernel set with vm kernel. Setting vm append<br/>without using vm kernel will result in an error.<br/></p>
<p>For example, to set a static IP for a linux VM:<br/></p>
<p><code>	vm config append ip=10.0.0.5 gateway=10.0.0.1 netmask=255.255.255.0 dns=10.10.10.10<br/>
</code><br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.10">vm config backchannel</h3>
</p>
<p><code> vm config backchannel [true,false]<br/>
</code><br/></p>
<p>Enable/disable serial command and control layer for this VM.<br/></p>
<p>Default: true<br/>
<p><h3 id="header_4.11">vm config cdrom</h3>
</p>
<p><code> vm config cdrom [value]<br/>
</code><br/></p>
<p>Attach a cdrom to a VM. When using a cdrom, it will automatically be set<br/>to be the boot device.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.12">vm config colocate</h3>
</p>
<p><code> vm config colocate [value]<br/>
</code><br/></p>
<p>Colocate this VM with another VM that has already been launched or is<br/>queued for launching.<br/></p>
<p>Note: Cannot specify Colocate and Schedule in the same<br/>
<p><h3 id="header_4.13">vm config cores</h3>
</p>
<p><code> vm config cores [value]<br/>
</code><br/></p>
<p>Set the number of CPU cores per socket. If unspecified, QEMU will<br/>calculate missing values based on vCPUs, sockets, and threads.<br/>
<p><h3 id="header_4.14">vm config coschedule</h3>
</p>
<p><code> vm config coschedule [value]<br/>
</code><br/></p>
<p>Set a limit on the number of VMs that should be scheduled on the same<br/>host as the VM. A limit of zero means that the VM should be scheduled by<br/>itself. A limit of -1 means that there is no limit. This is only used<br/>when launching VMs in a namespace.<br/></p>
<p>Default: -1<br/>
<p><h3 id="header_4.15">vm config cpu</h3>
</p>
<p><code> vm config cpu [value]<br/>
</code><br/></p>
<p>Set the virtual CPU architecture.<br/></p>
<p>By default, set to 'host' which matches the host CPU. See 'qemu -cpu<br/>help' for a list of supported CPUs.<br/></p>
<p>The accepted values for this configuration depend on the QEMU binary<br/>name specified by 'vm config qemu'.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/></p>
<p>Default: "host"<br/>
<p><h3 id="header_4.16">vm config disks</h3>
</p>
<p><code> vm config disks [diskspec]...<br/>
</code><br/></p>
<p>Specify one or more disks to be connected to a VM. Any disk image supported by QEMU is a valid parameter.<br/></p>
<p>Optionally, you may specify the drive interface for QEMU to use. By default,<br/>"ide" is used. Supported interfaces are "ahci", "ide", "scsi", "sd", "mtd",<br/>"floppy", "pflash", and "virtio".<br/></p>
<p>Optionally, you may specify the cache mode to be used by the drive. By default,<br/>"unsafe" is used for vms launched in snapshot mode, and "writeback" is used<br/>otherwise. Supported cache modes are "none", "writeback", "unsafe",<br/>"directsync", and "writethrough".<br/></p>
<p>Note: although disk snapshot image files are saved in the temporary vm instance<br/>paths, they may not be usable if the "unsafe" cache mode is used, as all flush<br/>commands from the guest are ignored in that cache mode. For example, even if<br/>you shut down the guest cleanly, there may still be data not yet written to the<br/>snapshot image file. If you wish to copy and use the snapshot image file<br/>cleanly, you can flush the disk cache manually via the QMP command socket, or<br/>specify a different cache mode such as "writeback".<br/></p>
<p>The order is:<br/></p>
<p><code>	&lt;path&gt;,&lt;interface&gt;,&lt;cache mode&gt;<br/>
</code><br/></p>
<p>Examples:<br/></p>
<p>To attach a disk with the default interface and cache mode:<br/></p>
<p><code>	vm config disk linux_disk.qcow2<br/>
</code><br/></p>
<p>To attach 2 disks using the "ide" interface for the first disk and default<br/>interface for the second disk:<br/></p>
<p><code>	vm config disk linux_disk.qcow2,ide storage_disk.qcow2<br/>
</code><br/></p>
<p>To attach a disk using the "ide" interface with the "unsafe" cache mode:<br/></p>
<p><code>	vm config disk linux_disk.qcow2,ide,unsafe<br/>
</code><br/></p>
<p>Disk images launched in snapshot mode may safely be used for multiple VMs.<br/></p>
<p>Calling vm config disks with no arguments prints the current configuration.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.17">vm config fifos</h3>
</p>
<p><code> vm config fifos [value]<br/>
</code><br/></p>
<p>Set the number of named pipes to include in the container for<br/>container-host communication. Named pipes will appear on the host in the<br/>instance directory for the container as fifoN, and on the container as<br/>/dev/fifos/fifoN.<br/></p>
<p>Fifos are created using mkfifo() and have all of the same usage<br/>constraints.<br/></p>
<p>Note: this configuration only applies to containers.<br/>
<p><h3 id="header_4.18">vm config filesystem</h3>
</p>
<p><code> vm config filesystem [value]<br/>
</code><br/></p>
<p>Configure the filesystem to use for launching a container. This should<br/>be a root filesystem for a linux distribution (containing /dev, /proc,<br/>/sys, etc.)<br/></p>
<p>Note: this configuration only applies to containers and must be specified.<br/>
<p><h3 id="header_4.19">vm config hostname</h3>
</p>
<p><code> vm config hostname [value]<br/>
</code><br/></p>
<p>Set a hostname for a container before launching the init program. If not<br/>set, the hostname will be the VM name. The hostname can also be set by<br/>the init program or other root process in the container.<br/></p>
<p>Note: this configuration only applies to containers.<br/>
<p><h3 id="header_4.20">vm config init</h3>
</p>
<p><code> vm config init [value]...<br/>
</code><br/></p>
<p>Set the init program and args to exec into upon container launch. This<br/>will be PID 1 in the container.<br/></p>
<p>Note: this configuration only applies to containers.<br/></p>
<p>Default: "/init"<br/>
<p><h3 id="header_4.21">vm config initrd</h3>
</p>
<p><code> vm config initrd [value]<br/>
</code><br/></p>
<p>Attach an initrd image to a VM. Passed along with the kernel image at<br/>boot time.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.22">vm config kernel</h3>
</p>
<p><code> vm config kernel [value]<br/>
</code><br/></p>
<p>Attach a kernel image to a VM. If set, QEMU will boot from this image<br/>instead of any disk image.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.23">vm config machine</h3>
</p>
<p><code> vm config machine [value]<br/>
</code><br/></p>
<p>Specify the machine type. See 'qemu -M help' for a list supported<br/>machine types.<br/></p>
<p>The accepted values for this configuration depend on the QEMU binary<br/>name specified by 'vm config qemu'.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.24">vm config memory</h3>
</p>
<p><code> vm config memory [value]<br/>
</code><br/></p>
<p>Configures the amount of physical memory to allocate (in megabytes).<br/></p>
<p>Default: 2048<br/>
<p><h3 id="header_4.25">vm config migrate</h3>
</p>
<p><code> vm config migrate [value]<br/>
</code><br/></p>
<p>Assign a migration image, generated by a previously saved VM to boot<br/>with. By default, images are read from the files directory as specified<br/>with -filepath. This can be overriden by using an absolute path.<br/>Migration images should be booted with a kernel/initrd, disk, or cdrom.<br/>Use 'vm migrate' to generate migration images from running VMs.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.26">vm config networks</h3>
</p>
<p><code> vm config networks [netspec]...<br/>
</code><br/></p>
<p>Specify the network(s) that the VM is a member of by VLAN. A corresponding VLAN<br/>will be created for each network. Optionally, you may specify the bridge the<br/>interface will be connected on. If the bridge name is omitted, minimega will<br/>use the default "mega_bridge".<br/></p>
<p>You can also optionally specify the MAC address of the interface to connect to<br/>that network. If not specifed, the MAC address will be randomly generated.<br/></p>
<p>You can also optionally specify a network device for qemu to use (which is<br/>ignored by containers). By default, "e1000" is used. To see a list of valid<br/>network devices, from run "qemu-kvm -device help".<br/></p>
<p>Finally, you can also optionally specify whether the interface should be<br/>configured in "dot1q-tunnel" mode (QinQ) in OVS. If so, the outer VLAN tag will<br/>be set to the minimega VLAN specified as part of the netspec.<br/></p>
<p>The order is:<br/></p>
<p><code>	&lt;bridge&gt;,&lt;VLAN&gt;,&lt;MAC&gt;,&lt;driver&gt;,&lt;qinq&gt;<br/>
</code><br/></p>
<p>Examples:<br/></p>
<p>To connect a VM to VLANs 1 and 5:<br/></p>
<p><code>	vm config net 1 5<br/>
</code><br/></p>
<p>To connect a VM to VLANs 100, 101, and 102 with specific mac addresses:<br/></p>
<p><code>	vm config net 100,00:00:00:00:00:00 101,00:00:00:00:01:00 102,00:00:00:00:02:00<br/>
</code><br/></p>
<p>To connect a VM to VLAN 1 on bridge0 and VLAN 2 on bridge1:<br/></p>
<p><code>	vm config net bridge0,1 bridge1,2<br/>
</code><br/></p>
<p>To connect a VM to VLAN 100 on bridge0 with a specific mac:<br/></p>
<p><code>	vm config net bridge0,100,00:11:22:33:44:55<br/>
</code><br/></p>
<p>To specify a specific driver, such as i82559c:<br/></p>
<p><code>	vm config net 100,i82559c<br/>
</code><br/></p>
<p>To specify the use of "dot1q-tunnel" mode with VLAN 105 as the outer VLAN:<br/></p>
<p><code>	vm config net 105,qinq<br/>
</code><br/></p>
<p>If you prefer, you can also use aliases for VLANs:<br/></p>
<p><code>	vm config net DMZ CORE<br/>
</code><br/></p>
<p>These aliases will be allocated from the pool of available VLANs and is<br/>namespace-aware (i.e. 'DMZ' in namespace 'foo' will be a different VLAN than<br/>'DMZ' in namespace 'bar'). Internally, this is implemented by concatenating the<br/>namespace name with the VLAN alias (e.g. 'DMZ' in namespace 'foo' becomes<br/>'foo//DMZ'). If you wish to connect VLANs in different namespaces, you may<br/>use/abuse this implementation detail:<br/></p>
<p><code>	namespace bar<br/>
	vm config net foo//DMZ<br/>
</code><br/></p>
<p>Calling vm config net with no arguments prints the current configuration.<br/>
<p><h3 id="header_4.27">vm config preinit</h3>
</p>
<p><code> vm config preinit [value]<br/>
</code><br/></p>
<p>Containers start in a highly restricted environment. vm config preinit<br/>allows running processes before isolation mechanisms are enabled. This<br/>occurs when the vm is launched and before the vm is put in the building<br/>state. preinit processes must finish before the vm will be allowed to<br/>start.<br/></p>
<p>Specifically, the preinit command will be run after entering namespaces,<br/>and mounting dependent filesystems, but before cgroups and root<br/>capabilities are set, and before entering the chroot. This means that<br/>the preinit command is run as root and can control the host.<br/></p>
<p>For example, to run a script that enables ip forwarding, which is not<br/>allowed during runtime because /proc is mounted read-only, add a preinit<br/>script:<br/></p>
<p><code>	vm config preinit enable_ip_forwarding.sh<br/>
</code><br/></p>
<p>Note: this configuration only applies to containers.<br/>
<p><h3 id="header_4.28">vm config qemu</h3>
</p>
<p><code> vm config qemu [value]<br/>
</code><br/></p>
<p>Set the QEMU binary name to invoke. Relative paths are ok.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/></p>
<p>Default: "kvm"<br/>
<p><h3 id="header_4.29">vm config qemu-append</h3>
</p>
<p><code> vm config qemu-append [value]...<br/>
</code><br/></p>
<p>Add additional arguments to be passed to the QEMU instance. For example:<br/></p>
<p><code>	vm config qemu-append -serial tcp:localhost:4001<br/>
</code><br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.30">vm config qemu-override</h3>
</p>
<p><code> vm config qemu-override<br/>
 vm config qemu-override &lt;match&gt; &lt;replacement&gt;<br/>
</code><br/></p>
<p>Override parts of the QEMU launch string by supplying a string to match, and a<br/>replacement string. Overrides are applied in the order that they are defined<br/><ul><li>and do not replace earlier overrides  if more than override share the same</li>
</ul><br/>"match" will later overrides will be applied to the overridden launch string.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.31">vm config schedule</h3>
</p>
<p><code> vm config schedule [value]<br/>
</code><br/></p>
<p>Set a host where the VM should be scheduled.<br/></p>
<p>Note: Cannot specify Schedule and Colocate in the same config.<br/>
<p><h3 id="header_4.32">vm config serial-ports</h3>
</p>
<p><code> vm config serial-ports [value]<br/>
</code><br/></p>
<p>Specify the serial ports that will be created for the VM to use. Serial<br/>ports specified will be mapped to the VM's /dev/ttySX device, where X<br/>refers to the connected unix socket on the host at<br/>$minimega_runtime/&lt;vm_id&gt;/serialX.<br/></p>
<p>Examples:<br/></p>
<p>To display current serial ports:<br/>  vm config serial-ports<br/></p>
<p>To create three serial ports:<br/>  vm config serial-ports 3<br/></p>
<p>Note: Whereas modern versions of Windows support up to 256 COM ports,<br/>Linux typically only supports up to four serial devices. To use more,<br/>make sure to pass "8250.n_uarts = 4" to the guest Linux kernel at boot.<br/>Replace 4 with another number.<br/>
<p><h3 id="header_4.33">vm config snapshot</h3>
</p>
<p><code> vm config snapshot [true,false]<br/>
</code><br/></p>
<p>Enable or disable snapshot mode for disk images and container<br/>filesystems. When enabled, disks/filesystems will have temporary snapshots created<br/>when run and changes will not be saved. This allows a single<br/>disk/filesystem to be used for many VMs.<br/></p>
<p>Default: true<br/>
<p><h3 id="header_4.34">vm config sockets</h3>
</p>
<p><code> vm config sockets [value]<br/>
</code><br/></p>
<p>Set the number of CPU sockets. If unspecified, QEMU will calculate<br/>missing values based on vCPUs, cores, and threads.<br/>
<p><h3 id="header_4.35">vm config tags</h3>
</p>
<p><code> vm config tags<br/>
 vm config tags &lt;key&gt; [value]<br/>
</code><br/></p>
<p>Set tags in the same manner as "vm tag". These tags will apply to all<br/>newly launched VMs.<br/>
<p><h3 id="header_4.36">vm config threads</h3>
</p>
<p><code> vm config threads [value]<br/>
</code><br/></p>
<p>Set the number of CPU threads per core. If unspecified, QEMU will<br/>calculate missing values based on vCPUs, sockets, and cores.<br/>
<p><h3 id="header_4.37">vm config uuid</h3>
</p>
<p><code> vm config uuid [value]<br/>
</code><br/></p>
<p>Configures the UUID for a virtual machine. If not set, the VM will be<br/>given a random one when it is launched.<br/>
<p><h3 id="header_4.38">vm config vcpus</h3>
</p>
<p><code> vm config vcpus [value]<br/>
</code><br/></p>
<p>Configures the number of virtual CPUs to allocate for a VM.<br/></p>
<p>Default: 1<br/>
<p><h3 id="header_4.39">vm config vga</h3>
</p>
<p><code> vm config vga [value]<br/>
</code><br/></p>
<p>Specify the graphics card to emulate. "cirrus" or "std" should work with<br/>most operating systems.<br/></p>
<p>Default: "std"<br/>
<p><h3 id="header_4.40">vm config virtio-ports</h3>
</p>
<p><code> vm config virtio-ports [value]<br/>
</code><br/></p>
<p>Specify the virtio-serial ports that will be created for the VM to use.<br/>Virtio-serial ports specified will be mapped to the VM's<br/>/dev/virtio-port/&lt;portname&gt; device, where &lt;portname&gt; refers to the<br/>connected unix socket on the host at<br/>$minimega_runtime/&lt;vm_id&gt;/virtio-serialX.<br/></p>
<p>Examples:<br/></p>
<p>To display current virtio-serial ports:<br/>  vm config virtio-ports<br/></p>
<p>To create three virtio-serial ports:<br/>  vm config virtio-ports 3<br/></p>
<p>To explicitly name the virtio-ports, pass a comma-separated list of names:<br/></p>
<p>  vm config virtio-ports foo,bar<br/></p>
<p>The ports (on the guest) will then be mapped to /dev/virtio-port/foo and<br/>/dev/virtio-port/bar.<br/>
<p><h3 id="header_4.41">vm config volume</h3>
</p>
<p><code> vm config volume<br/>
 vm config volume &lt;key&gt; [value]<br/>
</code><br/></p>
<p>Attach one or more volumes to a container. These directories will be<br/>mounted inside the container at the specified location.<br/></p>
<p>For example, to mount /scratch/data to /data inside the container:<br/></p>
<p><code> vm config volume /data /scratch/data<br/>
</code><br/></p>
<p>Commands with the same &lt;key&gt; will overwrite previous volumes:<br/></p>
<p><code> vm config volume /data /scratch/data2<br/>
 vm config volume /data<br/>
 /scratch/data2<br/>
</code><br/></p>
<p>Note: this configuration only applies to containers.<br/>
<p><h3 id="header_4.42">vm hotplug</h3>
</p>
<p><code> vm hotplug<br/>
 vm hotplug &lt;add,&gt; &lt;vm target&gt; &lt;filename&gt; [version]<br/>
 vm hotplug &lt;add,&gt; &lt;vm target&gt; &lt;filename&gt; serial &lt;serial&gt; [version]<br/>
 vm hotplug &lt;remove,&gt; &lt;vm target&gt; &lt;disk id or all&gt;<br/>
</code><br/></p>
<p>Add and remove USB drives to a launched VM.<br/></p>
<p>To view currently attached media, call vm hotplug with the 'show' argument and<br/>a VM name. To add a device, use the 'add' argument followed by the VM<br/>name, and the name of the file to add. For example, to add foo.img to VM foo:<br/></p>
<p><code>	vm hotplug add foo foo.img<br/>
</code><br/></p>
<p>The add command will assign a disk ID, shown in "vm hotplug". The optional<br/>parameter allows you to specify whether the drive will appear on the 1.1 or 2.0<br/>USB bus. For USB 1.1:<br/></p>
<p><code>	vm hotplug add foo foo.img 1.1<br/>
</code><br/></p>
<p>For USB 2.0:<br/></p>
<p><code>	vm hotplug add foo foo.img 2.0<br/>
</code><br/></p>
<p>To remove media, use the 'remove' argument with the VM name and the disk ID.<br/>For example, to remove the drive added above, named 0:<br/></p>
<p><code>	vm hotplug remove foo 0<br/>
</code><br/></p>
<p>To remove all hotplug devices, use ID "all" for the disk ID.<br/></p>
<p>See "vm start" for a full description of allowable targets.<br/>
<p><h3 id="header_4.43">vm info</h3>
</p>
<p><code> vm info [summary,]<br/>
</code><br/></p>
<p>Print information about VMs in tabular form. The .filter and .columns commands<br/>can be used to subselect a set of rows and/or columns. See the help pages for<br/>.filter and .columns, respectively, for their usage. Columns returned by VM<br/>info include:<br/></p>
<p><ul><li> id*        : the VM ID, as an integer</li>
<li> name*      : the VM name, if it exists</li>
<li> state*     : one of (building, running, paused, quit, error)</li>
<li> uptime     : amount of time since the VM was launched</li>
<li> namespace* : namespace the VM belongs to</li>
<li> type*      : one of (kvm, container)</li>
<li> uuid*      : QEMU system uuid</li>
<li> cc_active* : indicates whether cc is connected</li>
<li> vcpus      : the number of allocated CPUs</li>
<li> memory     : allocated memory, in megabytes</li>
<li> vlan*      : vlan, as an integer</li>
<li> bridge     : bridge name</li>
<li> tap        : tap name</li>
<li> mac        : mac address</li>
<li> ip         : IPv4 address</li>
<li> ip6        : IPv6 address</li>
<li> bandwidth  : stats regarding bandwidth usage</li>
<li> qos        : qualityofservice contraints on network interfaces</li>
<li> tags       : any additional information attached to the VM</li>
</ul><br/></p>
<p>Additional fields are available for KVM-based VMs:<br/></p>
<p><ul><li> append        : kernel command line string</li>
<li> cdrom         : cdrom image</li>
<li> disk          : disk image</li>
<li> kernel        : kernel image</li>
<li> initrd        : initrd image</li>
<li> migrate       : qemu migration image</li>
<li> pid           : pid of qemu process</li>
<li> serial        : number of serial ports</li>
<li> virtioserial : number of virtio ports</li>
<li> vnc_port      : port for VNC shim</li>
</ul><br/></p>
<p>Additional fields are available for container-based VMs:<br/></p>
<p><ul><li> filesystem   : root filesystem for the container</li>
<li> hostname     : hostname of the container</li>
<li> init	       : process to invoke as init</li>
<li> preinit      : process to invoke at container launch before isolation</li>
<li> pid          : pid of container's init process</li>
<li> fifo         : number of fifo devices</li>
<li> console_port : port for console shim</li>
</ul><br/></p>
<p>The optional summary flag limits the columns to those denoted with a '*'.<br/></p>
<p>Examples:<br/></p>
<p>Display a list of all IPs for all VMs:<br/><code>	.columns ip,ip6 vm info<br/>
</code><br/></p>
<p>Display information about all VMs:<br/><code>	vm info<br/>
</code><br/>
<p><h3 id="header_4.44">vm launch</h3>
</p>
<p><code> vm launch<br/>
 vm launch &lt;kvm,&gt; &lt;name or count&gt; [config]<br/>
 vm launch &lt;container,&gt; &lt;name or count&gt; [config]<br/>
</code><br/></p>
<p>Launch virtual machines in a paused state, using the parameters defined leading<br/>up to the launch command. Any changes to the VM parameters after launching will<br/>have no effect on launched VMs.<br/></p>
<p>When you launch a VM, you supply the type of VM in the launch command. The<br/>supported VM types are:<br/></p>
<p><ul><li> kvm : QEMUbased vms</li>
<li> container: Linux containers</li>
</ul><br/></p>
<p>If you supply a name instead of a number of VMs, one VM with that name will be<br/>launched. You may also supply a range expression to launch VMs with a specific<br/>naming scheme:<br/></p>
<p><code>	vm launch kvm foo[0-9]<br/>
</code><br/></p>
<p>Note: VM names cannot be integers or reserved words (e.g. "all").<br/></p>
<p>Users may specify a saved config explicity rather than use the current one, for<br/>example:<br/></p>
<p><code>	vm config save endpoint<br/>
	[other commands]<br/>
	vm launch kvm 5 endpoint<br/>
</code><br/></p>
<p>If queueing is enabled (see "ns"), VMs will be queued for launching until "vm<br/>launch" is called with no additional arguments. This allows the scheduler to<br/>better allocate resources across the cluster.<br/>
<p><h3 id="header_4.45">vm migrate</h3>
</p>
<p><code> vm migrate<br/>
 vm migrate &lt;vm name&gt; &lt;filename&gt;<br/>
</code><br/></p>
<p>Migrate runtime state of a VM to disk, which can later be booted with vm config<br/>migrate.<br/></p>
<p>Migration files are written to the files directory as specified with -filepath.<br/>On success, a call to migrate a VM will return immediately. You can check the<br/>status of in-flight migrations by invoking vm migrate with no arguments.<br/>
<p><h3 id="header_4.46">vm net</h3>
</p>
<p><code> vm net &lt;add,&gt; &lt;vm target&gt; [netspec]...<br/>
 vm net &lt;connect,&gt; &lt;vm target&gt; &lt;tap position&gt; &lt;vlan&gt; [bridge]<br/>
 vm net &lt;disconnect,&gt; &lt;vm target&gt; &lt;tap position&gt;<br/>
 vm net &lt;bond,&gt; &lt;vm target&gt; &lt;interface indexes&gt; &lt;active-backup,balance-slb,balance-tcp&gt; &lt;active,passive,off&gt; [qinq,]<br/>
 vm net &lt;bond,&gt; &lt;vm target&gt; &lt;interface indexes&gt; &lt;active-backup,balance-slb,balance-tcp&gt; &lt;active,passive,off&gt; name &lt;name&gt; [qinq,]<br/>
 vm net &lt;bond,&gt; &lt;vm target&gt; &lt;interface indexes&gt; &lt;active-backup,balance-slb,balance-tcp&gt; &lt;active,passive&gt; &lt;no-lacp-fallback,&gt; [qinq,]<br/>
 vm net &lt;bond,&gt; &lt;vm target&gt; &lt;interface indexes&gt; &lt;active-backup,balance-slb,balance-tcp&gt; &lt;active,passive&gt; &lt;no-lacp-fallback,&gt; name &lt;name&gt; [qinq,]<br/>
</code><br/></p>
<p>Add, disconnect, or move existing network connections for one or more VMs. See "vm<br/>start" for a full description of allowable targets.<br/></p>
<p>To add a network connection, you can specify the same options as you do when you add<br/>connections via vm config when launching VMs. See "vm config net" for more details.<br/></p>
<p>You will need to specify the VLAN of which the interface is a member. Optionally, you may<br/>specify the brige the interface will be connected on. You may also specify a MAC address for<br/>the interface. Finally, you may also specify the network device for qemu to use. By default,<br/>"e1000" is used. The order is:<br/></p>
<p><code>	&lt;bridge&gt;,&lt;VLAN&gt;,&lt;MAC&gt;,&lt;driver&gt;<br/>
</code><br/></p>
<p>So to add an interface to a vm called vm-0 that is a member of VLAN 100, with a specified MAC<br/>address, you can use:<br/></p>
<p><code>	vm net add vm-0 100,00:00:00:00:00:00<br/>
</code><br/></p>
<p>Network connections are indicated by their position in vm net (same order in vm<br/>info) and are zero indexed. For example, to disconnect the first network<br/>connection from a VM named vm-0:<br/></p>
<p><code>	vm net disconnect vm-0 0<br/>
</code><br/></p>
<p>To disconnect the second interface:<br/></p>
<p><code>	vm net disconnect vm-0 1<br/>
</code><br/></p>
<p>To move a connection, specify the interface number, the new VLAN tag and<br/>optional bridge:<br/></p>
<p><code>	vm net vm-0 0 100 mega_bridge<br/>
</code><br/></p>
<p>If the bridge name is omitted, the interface will be reconnected to the same<br/>bridge that it is already on. If the interface is not connected to a bridge, it<br/>will be connected to the default bridge, "mega_bridge".<br/></p>
<p>To create a bond comprised of two or more interfaces on a VM, use 'vm net bond'.<br/>For example, to create an 'active-backup' bond with interfaces 1 and 2 on VM foo<br/>with LACP set to active:<br/></p>
<p><code>	vm net bond foo 1,2 active-backup active<br/>
</code><br/></p>
<p>There are three bond modes supported: active-backup, balance-slb, and<br/>balance-tcp, and three LACP modes supported: active, passive, and off. To<br/>disable the bond if LACP negotiation fails instead of falling back to<br/>active-backup mode, provide the 'no-lacp-fallback' option.<br/></p>
<p>Bonds can also be configured in "dot1q-tunnel" mode (QinQ) in OVS with the<br/>"qinq" option. If configured in "dot1q-tunnel" mode, the outer VLAN tag will be<br/>set to the VLAN the bonded interfaces originally belonged to. Note that a bond<br/>will also be configured in "dot1q-tunnel" mode if at least one of the bonded<br/>interfaces was configured in "dot1q-tunnel" mode, even without the "qinq"<br/>option.<br/>
<p><h3 id="header_4.47">vm qmp</h3>
</p>
<p><code> vm qmp &lt;vm name&gt; &lt;qmp command&gt;<br/>
</code><br/></p>
<p>Issue a JSON-encoded QMP command. This is a convenience function for accessing<br/>the QMP socket of a VM via minimega. vm qmp takes two arguments, a VM name,<br/>and a JSON string, and returns the JSON encoded response. For example:<br/></p>
<p><code>	vm qmp 0 '{ "execute": "query-status" }'<br/>
	{"return":{"running":false,"singlestep":false,"status":"prelaunch"}}<br/>
</code><br/>
<p><h3 id="header_4.48">vm screenshot</h3>
</p>
<p><code> vm screenshot &lt;vm name&gt; [maximum dimension]<br/>
 vm screenshot &lt;vm name&gt; file &lt;filename&gt; [maximum dimension]<br/>
</code><br/></p>
<p>Take a screenshot of the framebuffer of a running VM. The screenshot is saved<br/>in PNG format as "screenshot.png" in the VM's runtime directory (by default<br/>/tmp/minimega/&lt;vm id&gt;/screenshot.png).<br/></p>
<p>An optional argument sets the maximum dimensions in pixels, while keeping the<br/>aspect ratio. For example, to set either maximum dimension of the output image<br/>to 100 pixels:<br/></p>
<p><code>	vm screenshot foo 100<br/>
</code><br/></p>
<p>The screenshot can be saved elsewhere like this:<br/></p>
<p><code>        vm screenshot foo file /tmp/foo.png<br/>
</code><br/></p>
<p>You can also specify the maximum dimension:<br/></p>
<p><code>        vm screenshot foo file /tmp/foo.png 100<br/>
</code><br/>
<p><h3 id="header_4.49">vm snapshot</h3>
</p>
<p><code> vm snapshot<br/>
 vm snapshot &lt;vm name&gt; &lt;state filename&gt; &lt;disk filename&gt;<br/>
</code><br/></p>
<p>Write VM state (migrate) and disk to file, which can later be booted with 'vm config<br/>migrate ...' and 'vm config disk ...', respectively.<br/></p>
<p>Saved migrate and disk files are written to the files directory as specified with<br/>-filepath. On success, a call to snapshot a VM will return immediately. You can<br/>check the status of in-flight snapshots by invoking vm snapshot with no arguments.<br/>
<p><h3 id="header_4.50">vm tag</h3>
</p>
<p><code> vm tag &lt;vm target&gt; [key or all]<br/>
 vm tag &lt;vm target&gt; &lt;key&gt; &lt;value&gt;<br/>
</code><br/></p>
<p>Display or set a tag for one or more virtual machines. See "vm start" for a<br/>full description of allowable targets.<br/></p>
<p>Tags are key-value pairs. A VM can have any number of tags associated with it.<br/>They can be used to attach additional information to a virtual machine, for<br/>example specifying a VM "group", or the correct rendering color for some<br/>external visualization tool.<br/></p>
<p>To set a tag "foo" to "bar" for VM 2:<br/></p>
<p><code>        vm tag 2 foo bar<br/>
</code><br/></p>
<p>To read a tag:<br/></p>
<p><code>        vm tag &lt;vm target&gt; &lt;key or all&gt;<br/>
</code><br/>
<p><h3 id="header_4.51">vm top</h3>
</p>
<p><code> vm top [duration]<br/>
</code><br/></p>
<p>View system resource utilization per VM. This is measured from the host and may<br/>differ from what is reported by the guest.<br/></p>
<p>The optional duration specifies the length of the sampling window in seconds.<br/>The command will block for at least this long while it measures usage. The<br/>default duration is one second.<br/></p>
<p>Returned columns include:<br/><ul><li> name      : name of the VM</li>
<li> namespace : namespace of the VM (when not in a namespace)</li>
<li> virt      : virtual memory size (MB)</li>
<li> res       : resident memory size (MB)</li>
<li> shr       : shared memory size (MB)</li>
<li> cpu       : host CPU usage (%)</li>
<li> vcpu      : guest CPU usage (%) (KVM only)</li>
<li> time      : total CPU time</li>
<li> procs     : number of processes inspected (limited to 100)</li>
<li> rx        : total received data rate (MB/s)</li>
<li> tx        : total transmitted data rate (MB/s)</li>
</ul><br/>
<p><h2 id="header_5.1">Host and Other Commands</h2>

<p><h3 id="header_5.2">host</h3>
</p>
<p><code> host<br/>
 host &lt;cpucommit,&gt;<br/>
 host &lt;cpus,&gt;<br/>
 host &lt;load,&gt;<br/>
 host &lt;memcommit,&gt;<br/>
 host &lt;memtotal,&gt;<br/>
 host &lt;memused,&gt;<br/>
 host &lt;name,&gt;<br/>
 host &lt;netcommit,&gt;<br/>
 host &lt;rx,&gt;<br/>
 host &lt;tx,&gt;<br/>
 host &lt;uptime,&gt;<br/>
 host &lt;vms,&gt;<br/>
 host &lt;vmlimit,&gt;<br/>
</code><br/></p>
<p>Report information about hosts in the current namespace:<br/></p>
<p><ul><li> cpucommit  : total cpu commit</li>
<li> cpus       : number of cpus</li>
<li> load       : system load average</li>
<li> memcommit  : total memory commit in MB</li>
<li> memtotal   : total memory in MB</li>
<li> memused    : memory used in MB</li>
<li> name       : name of the machine</li>
<li> netcommit  : total network interface commit</li>
<li> rx         : RX bandwidth stats (MB/s)</li>
<li> tx         : TX bandwidth stats (MB/s)</li>
<li> uptime     : uptime</li>
<li> vms        : number of VMs</li>
<li> vmlimit    : limit based on coschedule values (1 is no limit)</li>
</ul><br/></p>
<p>All VM-based stats are computed across namespaces.<br/>
<p><h3 id="header_5.3">background</h3>
</p>
<p><code> background &lt;command&gt;...<br/>
</code><br/></p>
<p>Execute a command under the credentials of the running user.<br/></p>
<p>Commands run in the background and control returns immediately. Any output is<br/>logged at the "info" level.<br/>
<p><h3 id="header_5.4">bridge</h3>
</p>
<p><code> bridge<br/>
 bridge &lt;config,&gt; &lt;bridge&gt; &lt;config&gt;<br/>
 bridge &lt;trunk,&gt; &lt;bridge&gt; &lt;interface&gt;<br/>
 bridge &lt;notrunk,&gt; &lt;bridge&gt; &lt;interface&gt;<br/>
 bridge &lt;tunnel,&gt; &lt;vxlan,gre&gt; &lt;bridge&gt; &lt;remote ip&gt; [key]<br/>
 bridge &lt;notunnel,&gt; &lt;bridge&gt; &lt;interface&gt;<br/>
 bridge &lt;destroy,&gt; &lt;bridge&gt;<br/>
</code><br/></p>
<p>When called with no arguments, display information about all managed bridges.<br/></p>
<p>To add a trunk interface to a specific bridge, use 'bridge trunk'. For example,<br/>to add interface bar to bridge foo:<br/></p>
<p><code>	bridge trunk foo bar<br/>
</code><br/></p>
<p>To create a vxlan or GRE tunnel to another bridge, use 'bridge tunnel'. For<br/>example, to create a vxlan tunnel to another bridge with IP 10.0.0.1:<br/></p>
<p><code>	bridge tunnel vxlan mega_bridge 10.0.0.1<br/>
</code><br/></p>
<p>Note: bridge is not a namespace-aware command.<br/>
<p><h3 id="header_5.5">capture</h3>
</p>
<p><code> capture &lt;netflow,&gt; &lt;bridge,&gt; &lt;bridge&gt; &lt;filename&gt;<br/>
 capture &lt;netflow,&gt; &lt;bridge,&gt; &lt;bridge&gt; &lt;tcp,udp&gt; &lt;hostname:port&gt;<br/>
 capture &lt;netflow,&gt; &lt;delete,&gt; bridge &lt;name&gt;<br/>
 capture &lt;netflow,&gt; &lt;timeout,&gt; [timeout in seconds]<br/>
 capture &lt;pcap,&gt; bridge &lt;bridge&gt; &lt;filename&gt;<br/>
 capture &lt;pcap,&gt; &lt;delete,&gt; bridge &lt;bridge&gt;<br/>
 capture<br/>
 capture &lt;pcap,&gt; vm &lt;vm name&gt; &lt;interface index&gt; &lt;filename&gt;<br/>
 capture &lt;pcap,&gt; &lt;delete,&gt; vm &lt;vm name&gt;<br/>
 capture &lt;pcap,&gt; &lt;snaplen,&gt; [size]<br/>
 capture &lt;pcap,&gt; &lt;filter,&gt; [bpf]<br/>
 capture &lt;netflow,&gt; &lt;mode,&gt; [raw,ascii]<br/>
 capture &lt;netflow,&gt; &lt;gzip,&gt; [true,false]<br/>
</code><br/></p>
<p>Note: the capture API is not fully namespace-aware and should be used with<br/>caution. See notes below.<br/></p>
<p>Capture experiment data including netflow and PCAP. Netflow capture obtains<br/>netflow data from any local openvswitch switch, and can write to file, another<br/>socket, or both. Netflow data can be written out in raw or ascii format, and<br/>file output can be compressed on the fly. Multiple netflow writers can be<br/>configured. There are several APIs to configure new netflow captures:<br/></p>
<p><code>	capture netflow mode [raw,ascii]<br/>
	capture netflow gzip [true,false]<br/>
	capture netflow timeout [timeout]<br/>
</code><br/></p>
<p>PCAP capture can be from a bridge or VM interface. To set the snaplen or filter<br/>for new PCAP captures, use:<br/></p>
<p><code>	capture pcap snaplen &lt;size&gt;<br/>
	capture pcap filter &lt;bpf&gt;<br/>
</code><br/></p>
<p>Examples:<br/></p>
<p><code>	# Capture netflow for mega_bridge to foo.netflow<br/>
	capture netflow bridge mega_bridge foo.netflow<br/>
</code><br/></p>
<p><code>	# Capture all bridge foo traffic to foo.pcap<br/>
	capture pcap bridge foo foo.pcap<br/>
</code><br/></p>
<p><code>	# Capture the 0-th interface for VM foo to foo.pcap<br/>
	capture pcap vm foo 0 foo.pcap<br/>
</code><br/></p>
<p>When run without arguments, capture prints all running captures. To stop a<br/>capture, use the delete commands:<br/></p>
<p><code>	capture netflow delete bridge &lt;bridge&gt;<br/>
	capture pcap delete bridge &lt;bridge&gt;<br/>
	capture pcap delete vm &lt;name&gt;<br/>
</code><br/></p>
<p>To stop all captures of a particular kind, replace &lt;bridge&gt; or &lt;vm&gt; with "all".<br/>If a VM has multiple interfaces and there are multiple captures running,<br/>calling "capture pcap delete vm &lt;name&gt;" stops all the captures for that VM. To<br/>stop all captures of all types, use "clear capture".<br/></p>
<p>Notes with namespaces:<br/><code> * Capturing traffic directly from the bridge (as PCAP or netflow) is not<br/>
</code><br/>   recommended if different namespaces share the same bridge. If this is the<br/>   case, the captured traffic would contain data from across namespaces.<br/><code> * Due to the way Open vSwitch implements netflow, there can be only one<br/>
</code><br/>   netflow object per bridge. This means that the netflow timeout is shared<br/>   across namespaces. Additionally, note that the API is also not<br/>   bridge-specific.<br/></p>
<p>Due to the above intricacies, the following commands only run on the local<br/>minimega instance:<br/></p>
<p><code>	capture &lt;netflow,&gt; &lt;bridge,&gt; &lt;bridge&gt; &lt;filename&gt;<br/>
	capture &lt;netflow,&gt; &lt;bridge,&gt; &lt;bridge&gt; &lt;tcp,udp&gt; &lt;hostname:port&gt;<br/>
	capture &lt;netflow,&gt; &lt;delete,&gt; bridge &lt;name&gt;<br/>
	capture &lt;netflow,&gt; &lt;timeout,&gt; [timeout in seconds]<br/>
	capture &lt;pcap,&gt; bridge &lt;bridge&gt; &lt;filename&gt;<br/>
	capture &lt;pcap,&gt; &lt;delete,&gt; bridge &lt;name&gt;<br/>
</code><br/>
<p><h3 id="header_5.6">cc</h3>
</p>
<p><code> cc<br/>
 cc &lt;listen,&gt; &lt;port&gt;<br/>
 cc &lt;clients,&gt;<br/>
 cc &lt;filter,&gt; [filter]...<br/>
 cc &lt;commands,&gt;<br/>
 cc &lt;prefix,&gt; [prefix]<br/>
 cc &lt;send,&gt; &lt;file&gt;...<br/>
 cc &lt;recv,&gt; &lt;file&gt;...<br/>
 cc &lt;exec,&gt; &lt;command&gt;...<br/>
 cc &lt;background,&gt; &lt;command&gt;...<br/>
 cc &lt;process,&gt; &lt;list,&gt; &lt;vm name, uuid or all&gt;<br/>
 cc &lt;process,&gt; &lt;kill,&gt; &lt;pid or all&gt;<br/>
 cc &lt;process,&gt; &lt;killall,&gt; &lt;name&gt;<br/>
 cc &lt;log,&gt; level &lt;debug,info,warn,error,fatal&gt;<br/>
 cc &lt;responses,&gt; &lt;id or prefix or all&gt; [raw,]<br/>
 cc &lt;tunnel,&gt; &lt;vm name or uuid&gt; &lt;src port&gt; &lt;host&gt; &lt;dst port&gt;<br/>
 cc &lt;rtunnel,&gt; &lt;src port&gt; &lt;host&gt; &lt;dst port&gt;<br/>
 cc &lt;delete,&gt; &lt;command,&gt; &lt;id or prefix or all&gt;<br/>
 cc &lt;delete,&gt; &lt;response,&gt; &lt;id or prefix or all&gt;<br/>
 cc &lt;test-conn,&gt; &lt;tcp,udp&gt; &lt;ip or fqdn&gt; &lt;port&gt; wait &lt;timeout&gt; [base64 udp packet]<br/>
</code><br/></p>
<p>Command and control for VMs running the miniccc client. Commands may include<br/>regular commands, backgrounded commands, and any number of sent and/or received<br/>files. Commands will be executed in command creation order. For example, to<br/>send a file 'foo' and display the contents on a remote VM:<br/></p>
<p><code>	cc send foo<br/>
	cc exec cat foo<br/>
</code><br/></p>
<p>Files to be sent must be in the filepath directory, as set by the -filepath<br/>flag when launching minimega.<br/></p>
<p>Executed commands can have their stdio tied to pipes used by the plumb and pipe<br/>APIs. To use named pipes, simply specify stdin, stdout, or stderr as a<br/>key=value pair. For example:<br/></p>
<p><code>	cc exec stderr=foo cat server.log<br/>
	cc background stdin=foo stdout=bar /usr/bin/program<br/>
</code><br/></p>
<p>Responses are organized in a structure within &lt;filepath&gt;/miniccc_responses, and<br/>include subdirectories for each client response named by the client's UUID.<br/>Responses can also be displayed on the command line with the 'responses'<br/>command.<br/></p>
<p>Filters may be set to limit which clients may execute a posted command.  For<br/>example, to filter on VMs that are running windows and have a specific IP.<br/></p>
<p><code>	cc filter os=windows ip=10.0.0.1<br/>
</code><br/></p>
<p>Users can also filter by VM tags. For example, to filter on VMs that have the<br/>tag with key foo and value bar set:<br/></p>
<p><code>	cc filter tag=foo:bar<br/>
</code><br/></p>
<p>If users wish, they may drop the tag= prefix and key=value pairs will be<br/>treated as tags:<br/></p>
<p><code>	cc filter foo=bar<br/>
</code><br/></p>
<p>Users can also filter by any column in "vm info" using a similar syntax:<br/></p>
<p><code>	cc filter name=server<br/>
	cc filter vlan=DMZ<br/>
</code><br/></p>
<p>"vm info" columns take precedance over tags when both define the same key.<br/></p>
<p>"cc mount" allows direct access to a guest's filesystem over the command and<br/>control connection. When given a VM uuid or name and a path, the VM's<br/>filesystem is mounted to the local machine at the provided path. "cc mount"<br/>without arguments displays the existing mounts. Users can use "clear cc mount"<br/>to unmount the filesystem of one or all VMs. This should be done before killing<br/>or stopping the VM ("clear namespace &lt;name&gt;" will handle this automatically).<br/></p>
<p>"cc test-conn" allows users to test network connectivity from a guest to the<br/>given IP or domain name and port. The wait timeout should be specified as a Go<br/>duration string (e.g. 5s, 1m). If "udp" is used, a "base64 udp packet" that will<br/>generate a valid response must be specified. Results of the test will be written<br/>to the command's STDOUT file, whether it passed or failed. An example test is as<br/>follows:<br/></p>
<p><code>	cc test-conn tcp 10.0.0.68 443 wait 10s<br/>
</code><br/></p>
<p>If the above test passes, STDOUT for the command will contain the following:<br/></p>
<p><code>	10.0.0.68:443 | pass<br/>
</code><br/></p>
<p>If it fails, STDOUT will instead contain the following:<br/></p>
<p><code>	10.0.0.68:443 | fail<br/>
</code><br/></p>
<p>For more documentation, see the article "Command and Control API Tutorial".<br/>
<p><h3 id="header_5.7">cc mount</h3>
</p>
<p><code> cc mount<br/>
 cc mount &lt;uuid or name&gt; [path]<br/>
</code><br/>
<p><h3 id="header_5.8">check</h3>
</p>
<p><code> check<br/>
</code><br/></p>
<p>minimega maintains a list of external packages that it depends on, such as<br/>qemu. Calling check will attempt to find each of these executables in the<br/>avaiable path and check to make sure they meet the minimum version<br/>requirements. Returns errors for all missing executables and all minimum<br/>versions not met.<br/>
<p><h3 id="header_5.9">clear all</h3>
</p>
<p><code> clear all<br/>
</code><br/></p>
<p><ul><li>Runs all the "clear ..." handlers on the local instance  as close to nuke as</li>
</ul><br/>you can get without restarting minimega. Restarting minimega is preferable.<br/>
<p><h3 id="header_5.10">clear capture</h3>
</p>
<p><code> clear capture [netflow,pcap]<br/>
</code><br/></p>
<p>Resets state for captures across the namespace. See "help capture" for more<br/>information.<br/>
<p><h3 id="header_5.11">clear cc</h3>
</p>
<p><code> clear cc<br/>
 clear cc &lt;commands,&gt;<br/>
 clear cc &lt;filter,&gt;<br/>
 clear cc &lt;prefix,&gt;<br/>
 clear cc &lt;responses,&gt;<br/>
</code><br/></p>
<p>Resets state for the command and control infrastructure provided by minimega.<br/>See "help cc" for more information.<br/>
<p><h3 id="header_5.12">clear cc mount</h3>
</p>
<p><code> clear cc mount [uuid or name or path]<br/>
</code><br/>
<p><h3 id="header_5.13">clear deploy flags</h3>
</p>
<p><code> clear deploy flags<br/>
</code><br/></p>
<p>Reset the deploy flags to their default value, which is equal to the launch<br/>flags used when launching minimega.<br/>
<p><h3 id="header_5.14">clear history</h3>
</p>
<p><code> clear history<br/>
</code><br/></p>
<p>Reset the command history. See "help history" for more information.<br/>
<p><h3 id="header_5.15">clear log</h3>
</p>
<p><code> clear log<br/>
 clear log &lt;file,&gt;<br/>
 clear log &lt;mesh,&gt;<br/>
 clear log &lt;level,&gt;<br/>
 clear log &lt;stderr,&gt;<br/>
 clear log &lt;filter,&gt;<br/>
 clear log &lt;syslog,&gt;<br/>
 clear log &lt;ring,&gt;<br/>
</code><br/></p>
<p>Resets state for logging. See "help log ..." for more information.<br/>
<p><h3 id="header_5.16">clear namespace</h3>
</p>
<p><code> clear namespace [name]<br/>
</code><br/></p>
<p>Without an argument, "clear namespace" will reset the namespace to the default<br/>namespace, minimega.<br/></p>
<p>With an argument, "clear namespace &lt;name&gt;" will destroy the specified<br/>namespace, cleaning up all state associated with it. You may use "all" to<br/>destroy all namespaces. This command is broadcast to the cluster to clean up<br/>any remote state as well.<br/>
<p><h3 id="header_5.17">clear optimize</h3>
</p>
<p><code> clear optimize<br/>
 clear optimize &lt;affinity,&gt; [filter,]<br/>
 clear optimize &lt;hugepages,&gt;<br/>
 clear optimize &lt;ksm,&gt;<br/>
</code><br/></p>
<p>Resets state for virtualization optimizations. See "help optimize" for more<br/>information.<br/>
<p><h3 id="header_5.18">clear pipe</h3>
</p>
<p><code> clear pipe [pipe]<br/>
 clear pipe &lt;pipe&gt; &lt;mode,&gt;<br/>
 clear pipe &lt;pipe&gt; &lt;log,&gt;<br/>
 clear pipe &lt;pipe&gt; &lt;via,&gt;<br/>
</code><br/>
<p><h3 id="header_5.19">clear plumb</h3>
</p>
<p><code> clear plumb [pipeline]...<br/>
</code><br/>
<p><h3 id="header_5.20">clear qos</h3>
</p>
<p><code> clear qos &lt;vm target&gt; [tap index]<br/>
</code><br/></p>
<p>Remove QoS constraints from a VM's interface. To clear QoS from all interfaces<br/>for a VM, use the wildcard:<br/></p>
<p><code>	clear qos foo all<br/>
</code><br/></p>
<p>See "vm start" for a full description of allowable targets.<br/>
<p><h3 id="header_5.21">clear router</h3>
</p>
<p><code> clear router<br/>
 clear router &lt;vm&gt;<br/>
 clear router &lt;vm&gt; &lt;rid,&gt;<br/>
 clear router &lt;vm&gt; &lt;interface,&gt;<br/>
 clear router &lt;vm&gt; &lt;interface,&gt; &lt;network&gt;<br/>
 clear router &lt;vm&gt; &lt;interface,&gt; &lt;network&gt; &lt;IPv4/MASK or IPv6/MASK or dhcp or all&gt; [lo,]<br/>
 clear router &lt;vm&gt; &lt;dhcp,&gt;<br/>
 clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt;<br/>
 clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;range,&gt;<br/>
 clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;router,&gt;<br/>
 clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;dns,&gt;<br/>
 clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;static,&gt;<br/>
 clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;static,&gt; &lt;mac&gt;<br/>
 clear router &lt;vm&gt; &lt;dns,&gt;<br/>
 clear router &lt;vm&gt; &lt;dns,&gt; &lt;ip&gt;<br/>
 clear router &lt;vm&gt; &lt;upstream,&gt;<br/>
 clear router &lt;vm&gt; &lt;gw,&gt;<br/>
 clear router &lt;vm&gt; &lt;ra,&gt;<br/>
 clear router &lt;vm&gt; &lt;ra,&gt; &lt;subnet&gt;<br/>
 clear router &lt;vm&gt; &lt;route,&gt;<br/>
 clear router &lt;vm&gt; &lt;route,&gt; &lt;static,namedstatic&gt;<br/>
 clear router &lt;vm&gt; &lt;route,&gt; &lt;static,&gt; &lt;network or all&gt; [staticroutename]<br/>
 clear router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt;<br/>
 clear router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt;<br/>
 clear router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt; &lt;network&gt;<br/>
 clear router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt; &lt;export,&gt; &lt;Ipv4/Mask or staticroutename&gt;<br/>
 clear router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt;<br/>
 clear router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt; &lt;rrclient,&gt;<br/>
 clear router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt; &lt;local,neighbor&gt;<br/>
 clear router &lt;vm&gt; &lt;fw,&gt;<br/>
</code><br/>
<p><h3 id="header_5.22">clear tap</h3>
</p>
<p><code> clear tap<br/>
 clear tap &lt;mirror,&gt; [name]<br/>
 clear tap &lt;mirror,&gt; &lt;vm name&gt; &lt;interface index or all&gt;<br/>
</code><br/></p>
<p>Reset state for taps. To delete individual taps, use "tap delete".<br/></p>
<p>"clear tap mirror" can be used to delete one or all mirrors. Mirrors are<br/>identified by the destination for the mirror since a source can have multiple<br/>mirrors. "clear tap" also deletes all mirrors.<br/></p>
<p>Only affects taps on the local node.<br/>
<p><h3 id="header_5.23">clear vlans</h3>
</p>
<p><code> clear vlans [prefix]<br/>
</code><br/></p>
<p>Clear one or more aliases, freeing the VLANs for reuse. You should only clear<br/>allocated VLANs once you have killed all the VMs connected to them.<br/></p>
<p>By default, "clear vlans" only clears aliases for the current namespace. If<br/>given "all" as the prefix, all state about managed VLANs is cleared across<br/><h3 id="header_5.24">all namespaces, including blacklisted VLANS. You should only use this if you</h3>
want a completely clean slate.<br/>
<p><h3 id="header_5.25">clear vnc</h3>
</p>
<p><code> clear vnc<br/>
</code><br/></p>
<p>Resets the state for VNC recordings. See "help vnc" for more information.<br/>
<p><h3 id="header_5.26">debug</h3>
</p>
<p><code> debug<br/>
 debug &lt;memory,&gt; &lt;file&gt;<br/>
 debug &lt;cpu,&gt; &lt;start,&gt; &lt;file&gt;<br/>
 debug &lt;cpu,&gt; &lt;stop,&gt;<br/>
 debug &lt;goroutine,&gt; &lt;file&gt;<br/>
</code><br/></p>
<p>debug can help find and resolve issues with minimega. Without arguments, debug<br/>prints the go version, the number of goroutines, and the number of cgo calls.<br/></p>
<p>With arguments, debug writes files that can be read using "go tool pprof":<br/></p>
<p><ul><li> memory: sampling of all heap allocations</li>
<li> cpu: starts CPU profiling (must be stopped before read)</li>
<li> goroutine: stack traces of all current goroutines</li>
</ul><br/>
<p><h3 id="header_5.27">deploy</h3>
</p>
<p><code> deploy &lt;launch,&gt; &lt;hosts&gt;<br/>
 deploy &lt;launch,&gt; &lt;hosts&gt; &lt;user&gt; [sudo,]<br/>
 deploy &lt;flags,&gt; [minimega flags]...<br/>
 deploy &lt;stdout,&gt; [path]<br/>
 deploy &lt;stderr,&gt; [path]<br/>
</code><br/></p>
<p>deploy copies and runs minimega on remote nodes, facilitating the deployment of<br/>minimega to a cluster. By default, deploy will launch minimega with the same<br/>flags used when starting this minimega, and add the -nostdin flag so that the<br/>remote minimega can be backgrounded. For example, to launch minimega on nodes<br/>kn1 and kn2:<br/></p>
<p><code>	deploy launch kn[1-2]<br/>
</code><br/></p>
<p>deploy uses scp/ssh to copy and run minimega. By default, minimega will attempt<br/>to login to remote nodes using the current user. This can be changed by<br/>providing a username. If using a different username, you can optionally specify<br/>the use of sudo when launching minimega (you typically need to run minimega as<br/>root).<br/></p>
<p>In order to override the flags passed to remote minimega instances, provide<br/>flags with 'deploy flags'. For example:<br/></p>
<p><code>	deploy flags -base=/opt/minimega -level=debug<br/>
</code><br/></p>
<p>To customize stdout and stderr, use 'deploy stdout' and 'deploy stderr':<br/></p>
<p><code>	deploy stdout /var/log/minimega.out<br/>
	deploy stderr /var/log/minimega.err<br/>
</code><br/></p>
<p>By default, stdout and stderr are written to /dev/null.<br/>
<p><h3 id="header_5.28">disk</h3>
</p>
<p><code> disk &lt;create,&gt; &lt;qcow2,raw&gt; &lt;image name&gt; &lt;size&gt;<br/>
 disk &lt;snapshot,&gt; &lt;image&gt; [dst image]<br/>
 disk &lt;inject,&gt; &lt;image&gt; files &lt;files like /path/to/src:/path/to/dst&gt;...<br/>
 disk &lt;inject,&gt; &lt;image&gt; options &lt;options&gt; files &lt;files like /path/to/src:/path/to/dst&gt;...<br/>
 disk &lt;info,&gt; &lt;image&gt;<br/>
</code><br/></p>
<p>Manipulate qcow disk images. Supports creating new images, snapshots of<br/>existing images, and injecting one or more files into an existing image.<br/></p>
<p>Example of creating a new disk:<br/></p>
<p><code>	disk create qcow2 foo.qcow2 100G<br/>
</code><br/></p>
<p>The size argument is the size in bytes, or using optional suffixes "k"<br/>(kilobyte), "M" (megabyte), "G" (gigabyte), "T" (terabyte).<br/></p>
<p>Example of taking a snapshot of a disk:<br/></p>
<p><code>	disk snapshot windows7.qc2 window7_miniccc.qc2<br/>
</code><br/></p>
<p>If the destination name is omitted, a name will be randomly generated and the<br/>snapshot will be stored in the 'files' directory. Snapshots are always created<br/>in the 'files' directory.<br/></p>
<p>To inject files into an image:<br/></p>
<p><code>	disk inject window7_miniccc.qc2 files "miniccc":"Program Files/miniccc"<br/>
</code><br/></p>
<p>Each argument after the image should be a source and destination pair,<br/>separated by a ':'. If the file paths contain spaces, use double quotes.<br/>Optionally, you may specify a partition (partition 1 will be used by default):<br/></p>
<p><code>	disk inject window7_miniccc.qc2:2 files "miniccc":"Program Files/miniccc"<br/>
</code><br/></p>
<p>You may also specify that there is no partition on the disk, if your filesystem<br/>was directly written to the disk (this is highly unusual):<br/></p>
<p><code>	disk inject partitionless_disk.qc2:none files /miniccc:/miniccc<br/>
</code><br/></p>
<p>You can optionally specify mount arguments to use with inject. Multiple options<br/>should be quoted. For example:<br/></p>
<p><code>	disk inject foo.qcow2 options "-t fat -o offset=100" files foo:bar<br/>
</code><br/></p>
<p>Disk image paths are always relative to the 'files' directory. Users may also<br/>use absolute paths if desired. The backing images for snapshots should always<br/>be in the files directory.<br/>
<p><h3 id="header_5.29">dnsmasq</h3>
</p>
<p><code> dnsmasq<br/>
 dnsmasq start &lt;listen address&gt; &lt;low dhcp range&gt; &lt;high dhcp range&gt; [config]<br/>
 dnsmasq start &lt;config&gt;<br/>
 dnsmasq kill &lt;id or all&gt;<br/>
</code><br/></p>
<p>Start a dhcp/dns server on a specified IP with a specified range. For example,<br/>to start a DHCP server on IP 10.0.0.1 serving the range 10.0.0.2 -<br/>10.0.254.254:<br/></p>
<p><code>	dnsmasq start 10.0.0.1 10.0.0.2 10.0.254.254<br/>
</code><br/></p>
<p>To start only a from a config file:<br/></p>
<p><code>	dnsmasq start /path/to/config<br/>
</code><br/></p>
<p>To list running dnsmasq servers, invoke dnsmasq with no arguments. To kill a<br/>running dnsmasq server, specify its ID from the list of running servers. For<br/>example, to kill dnsmasq server 2:<br/></p>
<p><code>	dnsmasq kill 2<br/>
</code><br/></p>
<p>To kill all running dnsmasq servers, pass all as the ID:<br/></p>
<p><code>	dnsmasq kill all<br/>
</code><br/></p>
<p>dnsmasq will provide DNS service from the host, as well as from /etc/hosts. You<br/>can specify an additional config file for dnsmasq by providing a file as an<br/>additional argument.<br/></p>
<p><code>	dnsmasq start 10.0.0.1 10.0.0.2 10.0.254.254 /tmp/dnsmasq-extra.conf<br/>
</code><br/></p>
<p>NOTE: If specifying an additional config file, you must provide the full path<br/>to the file.<br/>
<p><h3 id="header_5.30">dnsmasq configure</h3>
</p>
<p><code> dnsmasq configure &lt;ID&gt; &lt;ip,&gt;<br/>
 dnsmasq configure &lt;ID&gt; &lt;ip,&gt; &lt;mac address&gt; &lt;ip&gt;<br/>
 dnsmasq configure &lt;ID&gt; &lt;dns,&gt;<br/>
 dnsmasq configure &lt;ID&gt; &lt;dns,&gt; &lt;ip&gt; &lt;hostname&gt;<br/>
 dnsmasq configure &lt;ID&gt; &lt;dns,&gt; &lt;upstream,&gt;<br/>
 dnsmasq configure &lt;ID&gt; &lt;dns,&gt; &lt;upstream,&gt; server &lt;ip&gt;<br/>
 dnsmasq configure &lt;ID&gt; &lt;options,&gt;<br/>
 dnsmasq configure &lt;ID&gt; &lt;options,&gt; &lt;optionstring&gt;<br/>
</code><br/></p>
<p>Configuration options for running dnsmasq instances. Define a static IP<br/>allocation, specify a hostname-&gt;IP mapping for DNS, configure upstream DNS<br/>servers (useful when forwarding/NAT is enabled), or set DHCP options.<br/></p>
<p>To list all existing static IP allocations on the first running dnsmasq<br/>server, do the following:<br/></p>
<p><code>	dnsmasq configure 0 ip<br/>
</code><br/></p>
<p>To set up a static IP allocation for a VM with the MAC address<br/>00:11:22:33:44:55:<br/></p>
<p><code>	dnsmasq configure 0 ip 00:11:22:33:44:55 172.17.0.50<br/>
</code><br/></p>
<p>To see DNS entries:<br/></p>
<p><code>	dnsmasq configure 0 dns<br/>
</code><br/></p>
<p>To add a DNS entry:<br/></p>
<p><code>	dnsmasq configure 0 dns 172.17.0.50 example.com<br/>
</code><br/></p>
<p>To see upstream DNS servers:<br/></p>
<p><code>	dnsmasq configure 0 upstream<br/>
</code><br/></p>
<p>To add an upstream DNS server:<br/></p>
<p><code>	dnsmasq configure 0 upstream server 1.1.1.1<br/>
</code><br/></p>
<p>To see a list of all DHCP options:<br/></p>
<p><code>	dnsmasq configure 0 options<br/>
</code><br/></p>
<p>To add a DHCP option:<br/></p>
<p><code>	dnsmasq configure 0 options option:dns-server,172.17.0.254<br/>
</code><br/>
<p><h3 id="header_5.31">echo</h3>
</p>
<p><code> echo [args]...<br/>
</code><br/>
<p><h3 id="header_5.32">file</h3>
</p>
<p><code> file &lt;list,&gt;<br/>
 file &lt;list,&gt; &lt;path&gt; [recursive,]<br/>
 file &lt;get,&gt; &lt;file&gt;<br/>
 file &lt;stream,&gt; &lt;file&gt;<br/>
 file &lt;delete,&gt; &lt;file&gt;<br/>
 file &lt;status,&gt;<br/>
</code><br/></p>
<p>file allows you to transfer and manage files served by minimega in the<br/>directory set by the -filepath flag (default is 'base'/files).<br/></p>
<p>To list files currently being served, issue the list command with a directory<br/>relative to the served directory:<br/></p>
<p><code>	file list /foo<br/>
</code><br/></p>
<p>Issuing "file list /" will list the contents of the served directory.<br/></p>
<p>Files can be deleted with the delete command:<br/></p>
<p><code>	file delete /foo<br/>
</code><br/></p>
<p>If a directory is given, the directory will be recursively deleted.<br/></p>
<p>Files are transferred using the get command. When a get command is issued, the<br/>node will begin searching for a file matching the path and name within the mesh.<br/>If the file exists, it will be transferred to the requesting node. Which file is<br/>transferred over the mesh depends on the mode minimega is running in (see the<br/>"File transfer with minimega" article for details). When a file transfer begins,<br/>control will return to minimega while the transfer completes. If the -hashfiles<br/>flag is disabled (the default), and multiple files with the same name but<br/>different content exist across the mesh, the "file get" behavior for the file is<br/>undefined.<br/></p>
<p>If a directory is specified, that directory will be recursively transferred to<br/>the node.<br/></p>
<p>To see files that are currently being transferred, use the status command:<br/></p>
<p><code>	file status<br/>
</code><br/></p>
<p>You can also supply globs (wildcards) with the * operator. For example:<br/></p>
<p><code>	file get *.qcow2<br/>
	file delete *.qcow2<br/>
</code><br/></p>
<p>The stream command allows users to stream files through the Response. Each part<br/>of the file is returned as a separate response which can then be combined to<br/>form the original file. This command blocks until the stream is complete.<br/>
<p><h3 id="header_5.33">help</h3>
</p>
<p><code> help [command]...<br/>
</code><br/></p>
<p>Show help on a command. If called with no arguments, show a summary of all<br/>commands.<br/>
<p><h3 id="header_5.34">history</h3>
</p>
<p><code> history<br/>
</code><br/></p>
<p>history displays a list of all the commands that have been invoked since<br/>minimega started on this host, or since the last time the history was cleared.<br/>History includes only valid commands and comments. Invalid lines and blank<br/>lines are not recorded. There are some commands that interact differently with<br/>history, namely read. Instead of recording the "read" command in the history,<br/>minimega records all the valid commands executed from the read file in the<br/>history. This allows the full execution history to be listed using history.<br/>
<p><h3 id="header_5.35">log file</h3>
</p>
<p><code> log file [file]<br/>
</code><br/></p>
<p>Log to a file. To disable file logging, call "clear log file".<br/>
<p><h3 id="header_5.36">log filter</h3>
</p>
<p><code> log filter [filter]<br/>
</code><br/></p>
<p>Control what data gets logged based on matching text. For example, to filter<br/>out all logging messages containing the word "foo":<br/></p>
<p><code>	log filter foo<br/>
</code><br/>
<p><h3 id="header_5.37">log level</h3>
</p>
<p><code> log level [debug,info,warn,error,fatal]<br/>
</code><br/></p>
<p>Set the log level to one of [debug,info,warn,error,fatal]. Log levels inherit<br/>lower levels, so setting the level to error will also log fatal, and setting<br/>the mode to debug will log everything.<br/>
<p><h3 id="header_5.38">log mesh</h3>
</p>
<p><code> log mesh [node]<br/>
</code><br/></p>
<p>Log to a mesh node. To disable mesh logging, call "clear log mesh".<br/>
<p><h3 id="header_5.39">log ring</h3>
</p>
<p><code> log ring [size]<br/>
</code><br/></p>
<p>The log ring contains recent log messages, if it is enabled. By default<br/>the ring is not enabled. When enabling it, the user can specify a size. The<br/>larger the size, the more memory the logs will consume. The log ring can be<br/>cleared by re-enabling it with the same (or different) size.<br/></p>
<p>To disable the log ring, call "clear log ring".<br/>
<p><h3 id="header_5.40">log stderr</h3>
</p>
<p><code> log stderr [true,false]<br/>
</code><br/>
<p><h3 id="header_5.41">log syslog</h3>
</p>
<p><code> log syslog remote &lt;tcp,udp&gt; &lt;address&gt;<br/>
 log syslog &lt;local,&gt;<br/>
</code><br/></p>
<p>Log to a syslog daemon on the provided network and address. For example, to log<br/>over UDP to a syslog server foo on port 514:<br/></p>
<p><code>	log syslog udp foo:514<br/>
</code><br/>
<p><h3 id="header_5.42">namespace</h3>
</p>
<p><code> namespace [name]<br/>
 namespace &lt;name&gt; (command)<br/>
</code><br/></p>
<p>With no arguments, "namespace" prints summary info about namespaces:<br/></p>
<p><ul><li> name   : name of the namespace</li>
<li> vlans  : range of VLANs, empty if not set</li>
<li> active : active or not</li>
</ul><br/></p>
<p>When a namespace is specified, it changes the active namespace or runs a single<br/>command in the different namespace.<br/>
<p><h3 id="header_5.43">ns</h3>
</p>
<p><code> ns &lt;hosts,&gt;<br/>
 ns &lt;add-hosts,&gt; &lt;hostname or range or all&gt;<br/>
 ns &lt;del-hosts,&gt; &lt;hostname or range or all&gt;<br/>
 ns &lt;load,&gt;<br/>
 ns &lt;load,&gt; &lt;cpucommit,&gt;<br/>
 ns &lt;load,&gt; &lt;netcommit,&gt;<br/>
 ns &lt;load,&gt; &lt;memcommit,&gt;<br/>
 ns &lt;queue,&gt;<br/>
 ns &lt;flush,&gt;<br/>
 ns &lt;queueing,&gt; [true,false]<br/>
 ns &lt;schedule,&gt;<br/>
 ns &lt;schedule,&gt; &lt;dry-run,&gt;<br/>
 ns &lt;schedule,&gt; &lt;dump,&gt;<br/>
 ns &lt;schedule,&gt; &lt;mv,&gt; &lt;vm target&gt; &lt;dst&gt;<br/>
 ns &lt;schedule,&gt; &lt;status,&gt;<br/>
 ns &lt;bridge,&gt; &lt;bridge&gt; [vxlan,gre]<br/>
 ns &lt;del-bridge,&gt; &lt;bridge&gt;<br/>
 ns &lt;snapshot,&gt; [name]<br/>
 ns &lt;run,&gt; (command)<br/>
</code><br/></p>
<p>Display or modify the active namespace.<br/></p>
<p><ul><li> hosts     : list hosts</li>
<li> addhosts : add commaseparated list of hosts to the namespace</li>
<li> delhosts : delete commaseparated list of hosts from the namespace</li>
<li> load      : display or change host load is computed for scheduler, based on:</li>
<li>   cpucommit : total CPU commit divided by number of CPUs (default)</li>
<li>   netcommit : total NIC</li>
<li>   memcommit : total memory commit divided by total memory</li>
<li> queue     : display VM queue</li>
<li> flush     : clear the VM queue</li>
<li> queueing  : toggle VMs queueing when launching (default false)</li>
<li> schedule  : run scheduler (same as "vm launch")</li>
<li>   dryrun : determine VM placement and print out VM > host assignments</li>
<li>   dump    : print out VM > host assignments (after dryrun)</li>
<li>   mv      : manually edit VM placement in schedule (after dryrun)</li>
<li>   status  : display scheduling status</li>
<li> bridge    : create a bridge, defaults to GRE mesh between hosts</li>
<li> delbridge: destroy a bridge</li>
<li> snapshot  : take a snapshot of namespace or print snapshot progress</li>
<li> run       : run a command on all nodes in the namespace</li>
</ul><br/>
<p><h3 id="header_5.44">nuke</h3>
</p>
<p><code> nuke<br/>
</code><br/></p>
<p>After a crash, the VM state on the machine can be difficult to recover from.<br/>nuke attempts to kill all instances of QEMU, remove all taps and bridges, and<br/>removes the temporary minimega state on the harddisk.<br/></p>
<p>Should be run with caution.<br/>
<p><h3 id="header_5.45">optimize</h3>
</p>
<p><code> optimize<br/>
 optimize &lt;affinity,&gt; &lt;filter,&gt; &lt;filter&gt;<br/>
 optimize &lt;affinity,&gt; [true,false]<br/>
 optimize &lt;hugepages,&gt; [path]<br/>
 optimize &lt;ksm,&gt; [true,false]<br/>
</code><br/></p>
<p>Enable or disable several virtualization optimizations, including Kernel<br/>Samepage Merging, CPU affinity for VMs, and the use of hugepages.<br/></p>
<p>To enable/disable Kernel Samepage Merging (KSM):<br/></p>
<p><code>	optimize ksm [true,false]<br/>
</code><br/></p>
<p>To enable hugepage support for future VM launches:<br/></p>
<p><code>	optimize hugepages &lt;/path/to/hugepages_mount&gt;<br/>
</code><br/></p>
<p>To disable hugepage support:<br/></p>
<p><code>	clear optimize hugepages<br/>
</code><br/></p>
<p>To enable/disable CPU affinity support for VMs in the namespace:<br/></p>
<p><code>	optimize affinity [true,false]<br/>
</code><br/></p>
<p>To set a CPU set filter for the affinity scheduler, for example (to use only<br/>CPUs 1, 2-20):<br/></p>
<p><code>	optimize affinity filter [1,2-20]<br/>
</code><br/></p>
<p>If affinity is already enabled, will cause reassignment of affinity for all<br/>running VMs to match the new filter.<br/></p>
<p>To clear a CPU set filter:<br/></p>
<p><code>	clear optimize affinity filter<br/>
</code><br/></p>
<p>See note above about reassigning affinity.<br/></p>
<p>To view current CPU affinity mappings (by PID):<br/></p>
<p><code>	optimize affinity<br/>
</code><br/></p>
<p>To disable all optimizations, use "clear optimize".<br/></p>
<p>Note: affinity and hugepages can be selectively enabled in particular<br/>namespaces. KSM affects VMs across all namespaces.<br/>
<p><h3 id="header_5.46">pipe</h3>
</p>
<p><code> pipe &lt;pipe&gt; &lt;data&gt;<br/>
 pipe &lt;pipe&gt; &lt;via,&gt; &lt;command&gt;...<br/>
 pipe<br/>
 pipe &lt;pipe&gt; &lt;mode,&gt; &lt;all,round-robin,random&gt;<br/>
 pipe &lt;pipe&gt; &lt;log,&gt; &lt;true,false&gt;<br/>
</code><br/>
<p>Interact with named pipes. To write to a pipe, simply invoke the pipe API with<br/>the pipe name and value:<br/></p>
<p><code>	pipe foo Hello pipes!<br/>
</code><br/></p>
<p>Pipes have several message delivery modes. Based on the mode, messages written<br/>to a pipe will be delivered to one or more readers. Mode "all" copies messages<br/>to all readers, "round-robin" chooses a single reader, in-order, and "random"<br/>selects a random reader.<br/></p>
<p>Pipes can also have "vias", programs through which all written data is passed<br/>before being sent to readers. Unlike pipelines, vias are run for every reader.<br/>This allows for mutating data on a per-reader basis with a single write. For<br/>example, to send a unique floating-point value on a normal distribution with a<br/>written mean to all readers:<br/></p>
<p><code>	pipe foo via normal -stddev 5.0<br/>
	pipe foo 1.5<br/>
</code><br/></p>
<p>Pipes in other namespaces can be referenced with the syntax &lt;namespace&gt;//&lt;pipe&gt;.<br/>
<p><h3 id="header_5.47">plumb</h3>
</p>
<p><code> plumb &lt;src&gt; &lt;dst&gt;...<br/>
 plumb<br/>
</code><br/></p>
<p>Create pipelines composed of named pipes and external programs. Pipelines pass<br/>data on standard I/O, with messages split on newlines. Pipelines are<br/>constructed similar to that of UNIX pipelines. For example, to pipeline named<br/>pipe "foo" through "sed" and into another pipe "bar":<br/></p>
<p><code>	plumb foo "sed -u s/foo/moo/" bar<br/>
</code><br/></p>
<p>When specifying pipelines, strings that are not found in $PATH are considered<br/>named pipes.<br/></p>
<p>Pipelines can be composed into larger, nonlinear pipelines. For example, to<br/>create a simple tree rooted at A with leaves B and C, simply specify multiple<br/>pipelines:<br/></p>
<p><code>	plumb a b<br/>
	plumb a c<br/>
</code><br/>
<p><h3 id="header_5.48">qos</h3>
</p>
<p><code> qos &lt;add,&gt; &lt;vm target&gt; &lt;interface&gt; &lt;loss,&gt; &lt;percent&gt;<br/>
 qos &lt;add,&gt; &lt;vm target&gt; &lt;interface&gt; &lt;delay,&gt; &lt;duration&gt;<br/>
 qos &lt;add,&gt; &lt;vm target&gt; &lt;interface&gt; &lt;rate,&gt; &lt;bw&gt; &lt;kbit,mbit,gbit&gt;<br/>
</code><br/></p>
<p>Add quality-of-service (qos) constraints on mega interfaces to emulate real<br/>networks. Currently only applies qos constraints on the egress side / transmit<br/>direction. Qos constraints can be stacked with multiple calls to &lt;add&gt;, and<br/>must be specified explicitly. Any existing constraints will be overwritten by<br/>additional calls to &lt;add&gt;. VM can be specified with the same target syntax as<br/>the "vm start" api.<br/></p>
<p>Note that qos is namespace aware, and any qos commands will be matched to<br/>target vms within the currently active namespace.<br/></p>
<p>qos constraints include:<br/></p>
<p><ul><li> loss		: packets will be randomly dropped with a specified probability</li>
<li> delay		: delay packets for specified unit of time (ms, ns, etc)</li>
<li> rate		: impose a maximum bandwidth on an interface in kbit, mbit, or gbit</li>
</ul><br/></p>
<p>Note: due to limitations of the underlying tool, "tc", you can only add rate or<br/>loss/delay to a VM. Enabling loss or delay will disable rate and vice versa.<br/></p>
<p>Note: qos applies only to traffic received by the VM (which is "egress" traffic<br/><ul><li>on the mega_tap interface on the host)  traffic sent by the VM ("ingress" on</li>
</ul><br/>the mega_tap interface on the host) is not policed to the desired rate.<br/></p>
<p>Examples:<br/></p>
<p><code>	Randomly drop packets on the 0th interface for vms foo0, 1, and 2 with<br/>
	probability 25%<br/>
</code><br/></p>
<p><code>	qos add foo[0-2] 0 loss 25<br/>
</code><br/></p>
<p><code>	Add a 100ms delay to every packet on the 0th interface for vm foo and bar<br/>
</code><br/></p>
<p><code>	qos add foo,bar 0 delay 100ms<br/>
</code><br/></p>
<p><code>	Rate limit the 0th interface on all vms in the active namespace to 1mbit/s<br/>
</code><br/></p>
<p><code>	qos add all 0 rate 1 mbit<br/>
</code><br/></p>
<p>To clear active qos settings, use:<br/></p>
<p><code>	clear qos &lt;vm&gt; &lt;interface|all&gt;<br/>
</code><br/></p>
<p>Example:<br/></p>
<p><code>	clear qos foo all<br/>
</code><br/>
<p><h3 id="header_5.49">quit</h3>
</p>
<p><code> quit [delay]<br/>
</code><br/></p>
<p>Quit minimega. An optional integer argument X allows deferring the quit call<br/>for X seconds. This is useful for telling a mesh of minimega nodes to quit.<br/></p>
<p>quit will not return a response to the cli, control socket, or meshage, it will<br/>simply exit. meshage connected nodes catch this and will remove the quit node<br/>from the mesh. External tools interfacing minimega must check for EOF on stdout<br/>or the control socket as an indication that minimega has quit.<br/>
<p><h3 id="header_5.50">read</h3>
</p>
<p><code> read &lt;file&gt; [check,]<br/>
</code><br/></p>
<p>Read a command file and execute it. This has the same behavior as if you typed<br/>the file in manually. read stops if it reads an invalid command. read does not<br/>stop if a command returns an error. Nested reads are not permitted.<br/></p>
<p>To prevent issues with another script changing the namespace and commands being<br/>run in a different namespace than originally intended, read records the active<br/>namespace when it starts and prepends that namespace to all commands that it<br/>reads from the file. If it reads a command that would change the active<br/>namespace, read updates its state so that the new namespace is prepended<br/>instead.<br/></p>
<p>If the optional argument check is specified then read doesn't execute any of<br/>the commands in the file. Instead, it checks that all the commands are<br/>syntactically valid. This can identify mistyped commands in scripts before you<br/>read them. It cannot check for semantic errors (e.g. killing a non-existent<br/>VM). The check stops at the first invalid command.<br/>
<p><h3 id="header_5.51">router</h3>
</p>
<p><code> router &lt;vm&gt;<br/>
 router &lt;vm&gt; &lt;commit,&gt;<br/>
 router &lt;vm&gt; &lt;rid,&gt; &lt;id&gt;<br/>
 router &lt;vm&gt; &lt;log,&gt; &lt;level,&gt; &lt;fatal,error,warn,info,debug&gt;<br/>
 router &lt;vm&gt; &lt;interface,&gt; &lt;network&gt; &lt;IPv4/MASK or IPv6/MASK or dhcp&gt; [lo,]<br/>
 router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;range,&gt; &lt;low address&gt; &lt;high address&gt;<br/>
 router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;router,&gt; &lt;router address&gt;<br/>
 router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;dns,&gt; &lt;address&gt;<br/>
 router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;static,&gt; &lt;mac&gt; &lt;ip&gt;<br/>
 router &lt;vm&gt; &lt;dns,&gt; &lt;ip&gt; &lt;hostname&gt;<br/>
 router &lt;vm&gt; &lt;upstream,&gt; &lt;ip&gt;<br/>
 router &lt;vm&gt; &lt;gw,&gt; &lt;gw&gt;<br/>
 router &lt;vm&gt; &lt;ra,&gt; &lt;subnet&gt;<br/>
 router &lt;vm&gt; &lt;route,&gt; &lt;static,&gt; &lt;network&gt; &lt;next-hop&gt; [staticroutename]<br/>
 router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt; &lt;network&gt;<br/>
 router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt; &lt;network&gt; &lt;option&gt; &lt;value&gt;<br/>
 router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt; &lt;export,&gt; &lt;Ipv4/Mask or staticroutename&gt;<br/>
 router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt; &lt;local,neighbor&gt; &lt;IPv4&gt; &lt;asnumber&gt;<br/>
 router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt; &lt;rrclient,&gt;<br/>
 router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt; &lt;export,&gt; &lt;all,filter&gt; &lt;filtername&gt;<br/>
 router &lt;vm&gt; &lt;fw,&gt; &lt;default,&gt; &lt;accept,drop&gt;<br/>
 router &lt;vm&gt; &lt;fw,&gt; &lt;accept,drop,reject&gt; &lt;in,out&gt; &lt;index&gt; &lt;dst&gt; &lt;proto&gt;<br/>
 router &lt;vm&gt; &lt;fw,&gt; &lt;accept,drop,reject&gt; &lt;in,out&gt; &lt;index&gt; &lt;src&gt; &lt;dst&gt; &lt;proto&gt;<br/>
 router &lt;vm&gt; &lt;fw,&gt; chain &lt;chain&gt; &lt;default,&gt; action &lt;accept,drop,reject&gt;<br/>
 router &lt;vm&gt; &lt;fw,&gt; chain &lt;chain&gt; action &lt;accept,drop,reject&gt; &lt;dst&gt; &lt;proto&gt;<br/>
 router &lt;vm&gt; &lt;fw,&gt; chain &lt;chain&gt; action &lt;accept,drop,reject&gt; &lt;src&gt; &lt;dst&gt; &lt;proto&gt;<br/>
 router &lt;vm&gt; &lt;fw,&gt; chain &lt;chain&gt; apply &lt;in,out&gt; &lt;index&gt;<br/>
</code><br/></p>
<p>Configure running minirouter VMs running minirouter and miniccc.<br/></p>
<p>Routers are configured by specifying or updating a configuration, and then<br/>applying that configuration with a commit command. For example, to configure a<br/>router on a running VM named 'foo' to serve DHCP on 10.0.0.0/24 with a range of<br/>IPs:<br/></p>
<p><code>	router foo dhcp 10.0.0.0 range 10.0.0.100 10.0.0.200<br/>
	router foo commit<br/>
</code><br/></p>
<p>router takes a number of subcommands:<br/></p>
<p><ul><li> 'log': Change the log level of the minirouter tool on the VM.</li>
</ul><br/></p>
<p><ul><li> 'interface': Set IPv4 or IPv6 addresses, or configure an interface to assign</li>
</ul><br/>  using DHCP. The interface field is an integer index of the interface defined<br/>  with 'vm config net'. You could also specify if that interface will be a<br/>  loopback interface For example, to configure the second interface of the<br/>  router with a static IP and a loopback witha  different IP:<br/></p>
<p><code>	vm config net 100 200<br/>
	# ...<br/>
	router foo interface 1 10.0.0.1/24<br/>
	router foo interface 2 11.0.0.1/32 lo<br/>
</code><br/></p>
<p><ul><li> 'dhcp': Configure one or more DHCP servers on the router. The API allows you</li>
</ul><br/>  to set several options including static IP assignments and the default route<br/>  and DNS server. For example, to serve a range of IPs, with 2 static IPs<br/>  explicitly called out on router with IP 10.0.0.1:<br/></p>
<p><code>	router vm foo dhcp 10.0.0.0 range 10.0.0.2 10.0.0.254<br/>
	router vm foo dhcp 10.0.0.0 static 00:11:22:33:44:55 10.0.0.10<br/>
	router vm foo dhcp 10.0.0.0 static 00:11:22:33:44:56 10.0.0.11<br/>
</code><br/></p>
<p><ul><li> 'dns': Set DNS records for IPv4 or IPv6 hosts.</li>
</ul><br/></p>
<p><ul><li> 'upstream': Set upstream server for DNS.</li>
</ul><br/></p>
<p><ul><li> 'gw': Set default gateway which will be used if there is no matching route.</li>
</ul><br/></p>
<p><ul><li> 'ra': Enable neighbor discovery protocol router advertisements for a given</li>
</ul><br/>  subnet.<br/></p>
<p><ul><li> 'route': Set static, OSPF, or BGP routes. Static routes include a subnet,</li>
</ul><br/>  next-hop, and optionally a name for this router. For example to specify a<br/>  static route(s):<br/></p>
<p><code>	router foo route static 0.0.0.0/0 10.0.0.1 default-route<br/>
</code><br/></p>
<p>  OSPF routes include an area and a network index corresponding to the<br/>  interface described in 'vm config net'. You can also specify what networks<br/>  to advertise using the export command.<br/></p>
<p>  For example, to enable OSPF on area 0 for both interfaces of a router:<br/></p>
<p><code>	vm config net 100 200<br/>
	# ...<br/>
	router foo route ospf 0 0<br/>
	router foo route ospf 0 1<br/>
</code><br/></p>
<p>  For example, to advertise specific networks, advertise a static route or<br/>  use a static route as a filter:<br/></p>
<p><code>	router foo route static 11.0.0.0/24 0 bar-route<br/>
	router foo route static 12.0.0.0/24 0 bar-route<br/>
	router foo route ospf 0 export 10.0.0.0/24<br/>
	router foo route ospf 0 export default-route<br/>
	router foo route ospf 0 export bar-route<br/>
</code><br/></p>
<p>  To configure BGP must specify the process name for the specific bgp context, local ip address and AS,<br/>  Neighbor ip address and AS, and what networks need to be advertised<br/></p>
<p>  For example, local router is in AS 100 with an ip 10.0.0.1 and bgp peer is in AS 200 with an ip of 20.0.0.1<br/>  and you want to advterise network 10.0.0.0/24:<br/></p>
<p><code>	router foo route static 10.0.0.0/24 0 foo_out<br/>
	router foo bgp bar local 10.0.0.1 100<br/>
	router foo bgp bar neighbor 20.0.0.1 200<br/>
	router foo bgp bar export filter foo_out<br/>
</code><br/></p>
<p>  You can set up route reflection for BGP by ussing the rrclient command for that process.<br/>  By using the command it indicates that the peer is a bgp client:<br/></p>
<p><code>	router foo bgp bar rrclient<br/>
</code><br/></p>
<p><ul><li> 'rid': Sets the 32 bit router ID for the router. Typically this ID is unqiue</li>
</ul><br/>  across the orginizations network and is used for various routing protocols ie OSPF<br/></p>
<p><code>	router foo rid 1.1.1.1<br/>
</code><br/></p>
<p><ul><li> 'fw': specify flows to accept/drop/reject via iptables. For example, to</li>
</ul><br/>  globally globally drop all forwarded packets and accept HTTP traffic from any<br/>  IP address to host 192.168.0.5 on the interface at index 0 (which is on the<br/>  192.168.0.0/24 network):<br/></p>
<p><code>	router foo fw default drop<br/>
	router foo fw accept out 0 192.168.0.5:80 tcp<br/>
</code><br/></p>
<p>  Note that we use 'out' here since we're applying the rule to the interface<br/>  that's on the same network as the destination. The source and destination does<br/>  not have to include a port.<br/></p>
<p>  New iptables chains can also be created, providing a method for grouping rules<br/>  together instead of adding rules at the global level. Chains are then applied<br/>  to one or more interfaces using the interface index. For example, one could<br/>  put the previous rule into a chain named "allow-http" and apply it to the<br/>  interface at index 0 via the following:<br/></p>
<p><code>	router foo fw chain allow-http default action drop<br/>
	router foo fw chain allow-http action accept 192.168.0.5:80 tcp<br/>
	router foo fw chain allow-http apply out 0<br/>
</code><br/>
<p><h3 id="header_5.52">shell</h3>
</p>
<p><code> shell &lt;command&gt;...<br/>
</code><br/></p>
<p>Execute a command under the credentials of the running user.<br/></p>
<p>Commands run until they complete or error, so take care not to execute a command<br/>that does not return.<br/>
<p><h3 id="header_5.53">status updates</h3>
</p>
<p><code> status updates [frequency]<br/>
</code><br/></p>
<p>View or set how often status updates should be published by long running<br/>commands.<br/></p>
<p>Long running commands, like launching a VM that requires the VM's disk image to<br/>be transferred, can periodically publish status updates back to the original<br/>caller to show progress.<br/></p>
<p>By default, the status update frequency is 3s. Status updates can be disabled by<br/>setting this value to 0. Otherwise, when setting update frequency, valid Go time<br/>units must be used ("5s", "1m", etc.).<br/>
<p><h3 id="header_5.54">tap</h3>
</p>
<p><code> tap<br/>
 tap &lt;create,&gt; &lt;vlan&gt;<br/>
 tap &lt;create,&gt; &lt;vlan&gt; name &lt;tap name&gt;<br/>
 tap &lt;create,&gt; &lt;vlan&gt; &lt;dhcp,&gt; [tap name]<br/>
 tap &lt;create,&gt; &lt;vlan&gt; ip &lt;ip&gt; [tap name]<br/>
 tap &lt;create,&gt; &lt;vlan&gt; bridge &lt;bridge&gt;<br/>
 tap &lt;create,&gt; &lt;vlan&gt; bridge &lt;bridge&gt; name [tap name]<br/>
 tap &lt;create,&gt; &lt;vlan&gt; bridge &lt;bridge&gt; &lt;dhcp,&gt; [tap name]<br/>
 tap &lt;create,&gt; &lt;vlan&gt; bridge &lt;bridge&gt; ip &lt;ip&gt; [tap name]<br/>
 tap &lt;mirror,&gt; &lt;src name&gt; &lt;dst name&gt; [bridge]<br/>
 tap &lt;delete,&gt; &lt;tap name or all&gt;<br/>
 tap &lt;mirror,&gt; &lt;vm name&gt; &lt;interface index&gt; &lt;vm2 name&gt; &lt;interface2 index&gt;<br/>
</code><br/></p>
<p>Control host taps on a named vlan for communicating between a host and any VMs<br/>on that vlan.<br/></p>
<p>Calling tap with no arguments will list all created taps.<br/></p>
<p>To create a tap on a particular vlan, invoke tap with the create command:<br/></p>
<p><code>	tap create &lt;vlan&gt;<br/>
</code><br/></p>
<p>For example, to create a host tap with ip and netmask 10.0.0.1/24 on VLAN 5:<br/></p>
<p><code>	tap create 5 ip 10.0.0.1/24<br/>
</code><br/></p>
<p>Optionally, you can specify the bridge to create the host tap on:<br/></p>
<p><code>	tap create &lt;vlan&gt; bridge &lt;bridge&gt; ip &lt;ip&gt;<br/>
</code><br/></p>
<p>You can also optionally specify the tap name, otherwise the tap will be in the<br/>form of mega_tapX.<br/></p>
<p>Additionally, you can bring the tap up with DHCP by using "dhcp" instead of a<br/>ip/netmask:<br/></p>
<p><code>	tap create 5 dhcp<br/>
</code><br/></p>
<p>Tap mirror mirrors packets that traverse the source tap to the destination tap.<br/>Both taps should already exist. You can use taps for VMs from "vm info" or host<br/>taps. For example, to mirror traffic that traverse mega_tapX to mega_tapY on<br/>the default bridge:<br/></p>
<p><code>	tap mirror mega_tapX mega_tapY<br/>
</code><br/></p>
<p>Mirroring is also supported via vm names/interface indices. The VM interfaces<br/>should already be on the same bridge. VMs must be colocated.<br/></p>
<p>To delete a host tap, use the delete command and tap name from the tap list:<br/></p>
<p><code>	tap delete &lt;id&gt;<br/>
</code><br/></p>
<p>To delete all host taps, use id all, or 'clear tap':<br/></p>
<p><code>	tap delete all<br/>
</code><br/></p>
<p>Note: taps created while a namespace is active belong to that namespace and<br/>will only be listed when that namespace is active (or no namespace is active).<br/>Similarly, delete only applies to the taps in the active namespace. Unlike the<br/>"vlans" API, taps with the same name cannot exist in different namespaces.<br/>Create a mirror from one VM interface to another VM interface. The VMs must be<br/>running on the same physical node.<br/>
<p><h3 id="header_5.55">version</h3>
</p>
<p><code> version<br/>
</code><br/>
<p><h3 id="header_5.56">viz</h3>
</p>
<p><code> viz &lt;filename&gt;<br/>
</code><br/></p>
<p>Output the current experiment topology as a graphviz readable 'dot' file.<br/>
<p><h3 id="header_5.57">vlans</h3>
</p>
<p><code> vlans<br/>
 vlans &lt;range,&gt;<br/>
 vlans &lt;range,&gt; &lt;min&gt; &lt;max&gt;<br/>
 vlans &lt;add,&gt; &lt;alias&gt; &lt;vlan&gt;<br/>
 vlans &lt;blacklist,&gt; [vlan]<br/>
</code><br/></p>
<p>Display information about allocated VLANs. With no arguments, prints out the<br/>known VLAN aliases. The following subcommands are supported:<br/></p>
<p><ul><li>range		 view or set the VLAN range</li>
<li>add   		 add an alias</li>
<li>blacklist 	 view or create blacklisted VLAN</li>
</ul><br/></p>
<p>Note: this command is namespace aware so, for example, adding a range applies<br/>to all *new* VLAN aliases in the current namespace.<br/>
<p><h3 id="header_5.58">vnc</h3>
</p>
<p><code> vnc &lt;record,&gt; &lt;kb,fb&gt; &lt;vm name&gt; &lt;filename&gt;<br/>
 vnc &lt;stop,&gt; &lt;kb,fb&gt; &lt;vm name&gt;<br/>
 vnc &lt;play,&gt; &lt;vm target&gt; &lt;filename&gt;<br/>
 vnc &lt;stop,&gt; &lt;vm target&gt;<br/>
 vnc &lt;pause,&gt; &lt;vm target&gt;<br/>
 vnc &lt;continue,&gt; &lt;vm target&gt;<br/>
 vnc &lt;step,&gt; &lt;vm target&gt;<br/>
 vnc &lt;getstep,&gt; &lt;vm target&gt;<br/>
 vnc &lt;inject,&gt; &lt;vm target&gt; &lt;cmd&gt;<br/>
 vnc<br/>
</code><br/></p>
<p>Record keyboard and mouse events sent via the web interface to the<br/>selected VM. Can also record the framebuffer for the specified VM so that a<br/>user can watch a video of interactions with the VM.<br/></p>
<p>If record is selected, a file will be created containing a record of mouse<br/>and keyboard actions by the user or of the framebuffer for the VM.<br/></p>
<p>Note: recordings are written to the host where the VM is running.<br/>Playback and interact with a previously recorded vnc kb session file.<br/></p>
<p>If play is selected, the specified file (created using vnc record) will be read<br/>and processed as a sequence of time-stamped mouse/keyboard events to send to<br/>the specified VM(s). See "vm start" for a full description of the allowable<br/>targets. VMs without a valid playback that are part of the target will return a<br/>"kb playback not found" error.<br/></p>
<p>Playbacks can be paused with the pause command, and resumed using continue. The<br/>step command will immediately move to the next event contained in the playback<br/>file. Use the getstep command to view the current vnc event. Calling stop will<br/>end a playback.<br/></p>
<p>VNC playback also supports injecting mouse/keyboard events in the format found<br/>in the playback file. Injected commands must omit the time delta as they are<br/>sent immediately:<br/></p>
<p><code>	vnc inject vm-0 PointerEvent,0,465,245<br/>
</code><br/></p>
<p>New playback files can be injected as well:<br/></p>
<p><code>	vnc inject vm-0 LoadFile,foo.kb<br/>
</code><br/></p>
<p>Comments in the playback file are logged at the info level. An example is given<br/>below.<br/></p>
<p>#: This is an example of a vnc playback comment<br/>List all running vnc playback/recording instances. See "help vnc" for more information.<br/>
<p><h3 id="header_5.59">write</h3>
</p>
<p><code> write &lt;file&gt;<br/>
</code><br/></p>
<p>Write the command history to file. This is useful for handcrafting configs on<br/>the minimega command line and then saving them for later use.<br/>
    </main>

    <footer>
        
    </footer>

</body>
</html>
